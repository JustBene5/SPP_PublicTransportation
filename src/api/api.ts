/* tslint:disable */
/* eslint-disable */
/**
 * Disruption Reports
 * Specifications of the API endpoints of disruption reports.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ActualArrivalDepartureTimes
 */
export interface ActualArrivalDepartureTimes {
    /**
     * 
     * @type {boolean}
     * @memberof ActualArrivalDepartureTimes
     */
    'predicted'?: boolean;
    /**
     * 
     * @type {ArrivalDepartureTime}
     * @memberof ActualArrivalDepartureTimes
     */
    'times'?: ArrivalDepartureTime;
}
/**
 * 
 * @export
 * @interface ActualTripTimes
 */
export interface ActualTripTimes {
    /**
     * 
     * @type {boolean}
     * @memberof ActualTripTimes
     */
    'startPredicted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ActualTripTimes
     */
    'endPredicted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ActualTripTimes
     */
    'start'?: string;
    /**
     * 
     * @type {string}
     * @memberof ActualTripTimes
     */
    'end'?: string;
}
/**
 * 
 * @export
 * @interface ArrivalDepartureTime
 */
export interface ArrivalDepartureTime {
    /**
     * 
     * @type {string}
     * @memberof ArrivalDepartureTime
     */
    'arrival'?: string;
    /**
     * 
     * @type {string}
     * @memberof ArrivalDepartureTime
     */
    'departure'?: string;
}
/**
 * 
 * @export
 * @interface BasicAssignmentBody
 */
export interface BasicAssignmentBody {
    /**
     * 
     * @type {string}
     * @memberof BasicAssignmentBody
     */
    'user'?: string | null;
}
/**
 * Common properties for every representation of a block.
 * @export
 * @interface BasicBlock
 */
export interface BasicBlock {
    /**
     * 
     * @type {BlockIdentification}
     * @memberof BasicBlock
     */
    'identification'?: BlockIdentification;
    /**
     * 
     * @type {string}
     * @memberof BasicBlock
     */
    'tenant'?: string;
    /**
     * 
     * @type {string}
     * @memberof BasicBlock
     */
    'operatingDay'?: string;
    /**
     * 
     * @type {string}
     * @memberof BasicBlock
     */
    'lastModified'?: string;
}
/**
 * 
 * @export
 * @interface BasicChange
 */
export interface BasicChange {
    /**
     * 
     * @type {ChangeType}
     * @memberof BasicChange
     */
    'modifier': ChangeType;
}


/**
 * Common properties for every representation of a trip. Of the two fields plannedTimes and actualTimes only the planned times are always present. If the trip will begin soon, the actual trip times will be present. The actual trip times will start as a prediction of the times. After the trip was started, the start timestamp will switch to a logged one. After the trip was finished, the end timestamp will switch to a logged one.
 * @export
 * @interface BasicTrip
 */
export interface BasicTrip {
    /**
     * 
     * @type {TripIdentification}
     * @memberof BasicTrip
     */
    'identification': TripIdentification;
    /**
     * 
     * @type {string}
     * @memberof BasicTrip
     */
    'operatingDay'?: string;
    /**
     * 
     * @type {string}
     * @memberof BasicTrip
     */
    'destination'?: string;
    /**
     * 
     * @type {TripTimes}
     * @memberof BasicTrip
     */
    'plannedTimes': TripTimes;
    /**
     * 
     * @type {ActualTripTimes}
     * @memberof BasicTrip
     */
    'actualTimes'?: ActualTripTimes;
    /**
     * True iff the whole trip is cancelled.
     * @type {boolean}
     * @memberof BasicTrip
     */
    'cancelled'?: boolean;
    /**
     * Contains a list of cancelled trip segments. If the property cancelled is set to true, a single segment containing the whole itinerary is given.
     * @type {Array<CancelledSegment>}
     * @memberof BasicTrip
     */
    'cancelledSegments'?: Array<CancelledSegment>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const BehaviorAtStop = {
    Normal: 'NORMAL',
    Pass: 'PASS',
    NoEntry: 'NO_ENTRY',
    NoExit: 'NO_EXIT',
    ServiceStop: 'SERVICE_STOP'
} as const;

export type BehaviorAtStop = typeof BehaviorAtStop[keyof typeof BehaviorAtStop];


/**
 * Representation of a full block.
 * @export
 * @interface Block
 */
export interface Block {
    /**
     * List of all trips of the block in the correct order, i.e. the first entry of the list is the first trip of the block, the second entry is the second trip etc.
     * @type {Array<Trip>}
     * @memberof Block
     */
    'trips'?: Array<Trip>;
    /**
     * 
     * @type {BlockIdentification}
     * @memberof Block
     */
    'identification'?: BlockIdentification;
    /**
     * 
     * @type {string}
     * @memberof Block
     */
    'tenant'?: string;
    /**
     * 
     * @type {string}
     * @memberof Block
     */
    'operatingDay'?: string;
    /**
     * 
     * @type {string}
     * @memberof Block
     */
    'lastModified'?: string;
}
/**
 * 
 * @export
 * @interface BlockFilterSpec
 */
export interface BlockFilterSpec {
    /**
     * 
     * @type {Array<string>}
     * @memberof BlockFilterSpec
     */
    'vehicleUid'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof BlockFilterSpec
     */
    'blockUid'?: Array<string>;
}
/**
 * 
 * @export
 * @interface BlockIdentification
 */
export interface BlockIdentification {
    /**
     * 
     * @type {string}
     * @memberof BlockIdentification
     */
    'uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof BlockIdentification
     */
    'displayText'?: string;
}
/**
 * 
 * @export
 * @interface BlockSubscriptionRequestBody
 */
export interface BlockSubscriptionRequestBody {
    /**
     * 
     * @type {Array<BlockFilterSpec>}
     * @memberof BlockSubscriptionRequestBody
     */
    'filterKeys'?: Array<BlockFilterSpec>;
}
/**
 * Represents a cancelled node. Contains its identification (including posInRoute) and the planned arrival and departure time.
 * @export
 * @interface CancellationNode
 */
export interface CancellationNode {
    /**
     * 
     * @type {TripItineraryNodeIdentification}
     * @memberof CancellationNode
     */
    'identification'?: TripItineraryNodeIdentification;
    /**
     * 
     * @type {ArrivalDepartureTime}
     * @memberof CancellationNode
     */
    'timeInfo'?: ArrivalDepartureTime;
}
/**
 * Represents a segment of cancelled trip stops, i.e. all stops between (and including) start and end node are cancelled.
 * @export
 * @interface CancelledSegment
 */
export interface CancelledSegment {
    /**
     * 
     * @type {CancellationNode}
     * @memberof CancelledSegment
     */
    'startNode'?: CancellationNode;
    /**
     * 
     * @type {CancellationNode}
     * @memberof CancelledSegment
     */
    'endNode'?: CancellationNode;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ChangeType = {
    Create: 'CREATE',
    Update: 'UPDATE',
    Delete: 'DELETE'
} as const;

export type ChangeType = typeof ChangeType[keyof typeof ChangeType];


/**
 * Condensed view of a block.
 * @export
 * @interface CondensedBlock
 */
export interface CondensedBlock {
    /**
     * List of all trips (represented in a condensed view) of the block in the correct order, i.e. the first entry of the list is the first trip of the block, the second entry is the second trip etc.
     * @type {Array<CondensedTrip>}
     * @memberof CondensedBlock
     */
    'trips'?: Array<CondensedTrip>;
    /**
     * 
     * @type {BlockIdentification}
     * @memberof CondensedBlock
     */
    'identification'?: BlockIdentification;
    /**
     * 
     * @type {string}
     * @memberof CondensedBlock
     */
    'tenant'?: string;
    /**
     * 
     * @type {string}
     * @memberof CondensedBlock
     */
    'operatingDay'?: string;
    /**
     * 
     * @type {string}
     * @memberof CondensedBlock
     */
    'lastModified'?: string;
}
/**
 * 
 * @export
 * @interface CondensedBlockChange
 */
export interface CondensedBlockChange {
    /**
     * 
     * @type {CondensedBlock}
     * @memberof CondensedBlockChange
     */
    'value': CondensedBlock;
    /**
     * 
     * @type {ChangeType}
     * @memberof CondensedBlockChange
     */
    'modifier': ChangeType;
}


/**
 * 
 * @export
 * @interface CondensedBlocksResponse
 */
export interface CondensedBlocksResponse {
    /**
     * 
     * @type {Array<CondensedBlock>}
     * @memberof CondensedBlocksResponse
     */
    'data'?: Array<CondensedBlock>;
}
/**
 * A condensed view of a trip.
 * @export
 * @interface CondensedTrip
 */
export interface CondensedTrip {
    /**
     * 
     * @type {TripItineraryNodeIdentification}
     * @memberof CondensedTrip
     */
    'firstTripItineraryNode': TripItineraryNodeIdentification;
    /**
     * 
     * @type {TripItineraryNodeIdentification}
     * @memberof CondensedTrip
     */
    'lastTripItineraryNode': TripItineraryNodeIdentification;
    /**
     * 
     * @type {TripIdentification}
     * @memberof CondensedTrip
     */
    'identification': TripIdentification;
    /**
     * 
     * @type {string}
     * @memberof CondensedTrip
     */
    'operatingDay'?: string;
    /**
     * 
     * @type {string}
     * @memberof CondensedTrip
     */
    'destination'?: string;
    /**
     * 
     * @type {TripTimes}
     * @memberof CondensedTrip
     */
    'plannedTimes': TripTimes;
    /**
     * 
     * @type {ActualTripTimes}
     * @memberof CondensedTrip
     */
    'actualTimes'?: ActualTripTimes;
    /**
     * True iff the whole trip is cancelled.
     * @type {boolean}
     * @memberof CondensedTrip
     */
    'cancelled'?: boolean;
    /**
     * Contains a list of cancelled trip segments. If the property cancelled is set to true, a single segment containing the whole itinerary is given.
     * @type {Array<CancelledSegment>}
     * @memberof CondensedTrip
     */
    'cancelledSegments'?: Array<CancelledSegment>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DemandType = {
    NoDemand: 'NO_DEMAND',
    Onboarding: 'ONBOARDING',
    Deboarding: 'DEBOARDING',
    Both: 'BOTH'
} as const;

export type DemandType = typeof DemandType[keyof typeof DemandType];


/**
 * 
 * @export
 * @interface Destination
 */
export interface Destination {
    /**
     * 
     * @type {string}
     * @memberof Destination
     */
    'lastStopName'?: string;
}
/**
 * 
 * @export
 * @interface Deviation
 */
export interface Deviation {
    /**
     * 
     * @type {number}
     * @memberof Deviation
     */
    'value'?: number;
    /**
     * 
     * @type {DeviationPrefix}
     * @memberof Deviation
     */
    'prefix'?: DeviationPrefix | null;
    /**
     * 
     * @type {DeviationSemantics}
     * @memberof Deviation
     */
    'semantics'?: DeviationSemantics;
    /**
     * 
     * @type {DeviationObsolescenceStage}
     * @memberof Deviation
     */
    'obsolescenceStage'?: DeviationObsolescenceStage;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const DeviationObsolescenceStage = {
    Fresh: 'FRESH',
    Old: 'OLD',
    Ancient: 'ANCIENT'
} as const;

export type DeviationObsolescenceStage = typeof DeviationObsolescenceStage[keyof typeof DeviationObsolescenceStage];


/**
 * 
 * @export
 * @enum {string}
 */

export const DeviationPrefix = {
    Star: '*',
    Plus: '+',
    Minus: '-',
    Percent: '%',
    Hash: '#',
    Equal: '='
} as const;

export type DeviationPrefix = typeof DeviationPrefix[keyof typeof DeviationPrefix];


/**
 * 
 * @export
 * @enum {string}
 */

export const DeviationSemantics = {
    OnTime: 'ON_TIME',
    Suboptimal: 'SUBOPTIMAL',
    Problematic: 'PROBLEMATIC',
    NotAvailable: 'NOT_AVAILABLE',
    Waiting: 'WAITING'
} as const;

export type DeviationSemantics = typeof DeviationSemantics[keyof typeof DeviationSemantics];


/**
 * 
 * @export
 * @interface DisruptionReport
 */
export interface DisruptionReport {
    /**
     * 
     * @type {string}
     * @memberof DisruptionReport
     */
    'uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof DisruptionReport
     */
    'tenant'?: string;
    /**
     * 
     * @type {NotificationCategory}
     * @memberof DisruptionReport
     */
    'category'?: NotificationCategory;
    /**
     * 
     * @type {string}
     * @memberof DisruptionReport
     */
    'operatingDay'?: string;
    /**
     * 
     * @type {string}
     * @memberof DisruptionReport
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof DisruptionReport
     */
    'creationTime'?: string;
    /**
     * 
     * @type {NotificationOrigin}
     * @memberof DisruptionReport
     */
    'origin'?: NotificationOrigin;
    /**
     * 
     * @type {string}
     * @memberof DisruptionReport
     */
    'text'?: string;
    /**
     * 
     * @type {number}
     * @memberof DisruptionReport
     */
    'priority'?: number;
    /**
     * 
     * @type {LineIdentification}
     * @memberof DisruptionReport
     */
    'line'?: LineIdentification;
    /**
     * 
     * @type {Position}
     * @memberof DisruptionReport
     */
    'position'?: Position;
    /**
     * 
     * @type {Destination}
     * @memberof DisruptionReport
     */
    'destination'?: Destination;
    /**
     * 
     * @type {string}
     * @memberof DisruptionReport
     */
    'user'?: string;
    /**
     * 
     * @type {VehicleIdentification}
     * @memberof DisruptionReport
     */
    'vehicle'?: VehicleIdentification;
    /**
     * voice radio ID of the vehicle
     * @type {string}
     * @memberof DisruptionReport
     */
    'voiceRadioId'?: string;
    /**
     * 
     * @type {Deviation}
     * @memberof DisruptionReport
     */
    'deviation'?: Deviation;
    /**
     * 
     * @type {DriverIdentification}
     * @memberof DisruptionReport
     */
    'driver'?: DriverIdentification;
    /**
     * 
     * @type {Occupancy}
     * @memberof DisruptionReport
     */
    'occupancy'?: Occupancy;
    /**
     * 
     * @type {Array<number>}
     * @memberof DisruptionReport
     */
    'trailers'?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof DisruptionReport
     */
    'remainingRange'?: number;
    /**
     * 
     * @type {number}
     * @memberof DisruptionReport
     */
    'stateOfCharge'?: number;
    /**
     * 
     * @type {BlockIdentification}
     * @memberof DisruptionReport
     */
    'block'?: BlockIdentification;
    /**
     * 
     * @type {TripIdentification}
     * @memberof DisruptionReport
     */
    'trip'?: TripIdentification;
}


/**
 * 
 * @export
 * @interface DisruptionReportChange
 */
export interface DisruptionReportChange {
    /**
     * 
     * @type {DisruptionReport}
     * @memberof DisruptionReportChange
     */
    'value': DisruptionReport;
    /**
     * 
     * @type {ChangeType}
     * @memberof DisruptionReportChange
     */
    'modifier': ChangeType;
}


/**
 * 
 * @export
 * @interface DisruptionReportsAssignmentBody
 */
export interface DisruptionReportsAssignmentBody {
    /**
     * 
     * @type {string}
     * @memberof DisruptionReportsAssignmentBody
     */
    'user'?: string | null;
}
/**
 * 
 * @export
 * @interface DisruptionReportsFilterSpec
 */
export interface DisruptionReportsFilterSpec {
    /**
     * 
     * @type {Array<string>}
     * @memberof DisruptionReportsFilterSpec
     */
    'tenant'?: Array<string>;
}
/**
 * 
 * @export
 * @interface DisruptionReportsResponse
 */
export interface DisruptionReportsResponse {
    /**
     * 
     * @type {Array<DisruptionReport>}
     * @memberof DisruptionReportsResponse
     */
    'data'?: Array<DisruptionReport>;
}
/**
 * 
 * @export
 * @interface DisruptionReportsSubscriptionRequestBody
 */
export interface DisruptionReportsSubscriptionRequestBody {
    /**
     * 
     * @type {Array<DisruptionReportsFilterSpec>}
     * @memberof DisruptionReportsSubscriptionRequestBody
     */
    'filterKeys'?: Array<DisruptionReportsFilterSpec>;
}
/**
 * 
 * @export
 * @interface DriverIdentification
 */
export interface DriverIdentification {
    /**
     * 
     * @type {string}
     * @memberof DriverIdentification
     */
    'uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof DriverIdentification
     */
    'displayText'?: string;
}
/**
 * 
 * @export
 * @interface DutyIdentification
 */
export interface DutyIdentification {
    /**
     * 
     * @type {string}
     * @memberof DutyIdentification
     */
    'uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof DutyIdentification
     */
    'displayText'?: string;
}
/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'uid': string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'creationTime': string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    'type': string;
    /**
     * 
     * @type {EventAffectedObjects}
     * @memberof Event
     */
    'affectedObjects'?: EventAffectedObjects;
}
/**
 * the objects which are affected by this event
 * @export
 * @interface EventAffectedObjects
 */
export interface EventAffectedObjects {
    /**
     * 
     * @type {Array<VehicleIdentification>}
     * @memberof EventAffectedObjects
     */
    'vehicles'?: Array<VehicleIdentification>;
}
/**
 * 
 * @export
 * @interface EventChange
 */
export interface EventChange {
    /**
     * 
     * @type {Event}
     * @memberof EventChange
     */
    'value': Event;
    /**
     * 
     * @type {ChangeType}
     * @memberof EventChange
     */
    'modifier': ChangeType;
}


/**
 * 
 * @export
 * @interface EventsFilterSpec
 */
export interface EventsFilterSpec {
    /**
     * 
     * @type {Array<string>}
     * @memberof EventsFilterSpec
     */
    'vehicleUid'?: Array<string>;
}
/**
 * 
 * @export
 * @interface EventsResponse
 */
export interface EventsResponse {
    /**
     * 
     * @type {Array<Event>}
     * @memberof EventsResponse
     */
    'data'?: Array<Event>;
}
/**
 * 
 * @export
 * @interface EventsSubscriptionRequestBody
 */
export interface EventsSubscriptionRequestBody {
    /**
     * 
     * @type {Array<EventsFilterSpec>}
     * @memberof EventsSubscriptionRequestBody
     */
    'filterKeys'?: Array<EventsFilterSpec>;
}
/**
 * 
 * @export
 * @interface GeoDirection
 */
export interface GeoDirection {
    /**
     * 
     * @type {number}
     * @memberof GeoDirection
     */
    'angle'?: number;
    /**
     * 
     * @type {string}
     * @memberof GeoDirection
     */
    'displayText'?: string;
}
/**
 * A GPS position. Longitude and latitude are given in WGS 84 format.
 * @export
 * @interface GpsPosition
 */
export interface GpsPosition {
    /**
     * 
     * @type {number}
     * @memberof GpsPosition
     */
    'longitude'?: number;
    /**
     * 
     * @type {number}
     * @memberof GpsPosition
     */
    'latitude'?: number;
}
/**
 * 
 * @export
 * @interface Instruction
 */
export interface Instruction {
    /**
     * 
     * @type {string}
     * @memberof Instruction
     */
    'tenant'?: string;
    /**
     * 
     * @type {InstructionTemplateIdentification}
     * @memberof Instruction
     */
    'template'?: InstructionTemplateIdentification;
    /**
     * not applicable when type is \'PREDEFINED\'
     * @type {string}
     * @memberof Instruction
     */
    'text'?: string;
    /**
     * Indicates whether the addressed driver shall acknowledge the receipt.
     * @type {boolean}
     * @memberof Instruction
     */
    'driverAcknowledgement'?: boolean;
    /**
     * 
     * @type {InstructionRecipients}
     * @memberof Instruction
     */
    'recipients'?: InstructionRecipients;
}
/**
 * 
 * @export
 * @interface InstructionRecipients
 */
export interface InstructionRecipients {
    /**
     * 
     * @type {Array<VehicleIdentification>}
     * @memberof InstructionRecipients
     */
    'vehicles'?: Array<VehicleIdentification>;
}
/**
 * The identification property of an instruction template is read-only.
 * @export
 * @interface InstructionTemplate
 */
export interface InstructionTemplate {
    /**
     * 
     * @type {string}
     * @memberof InstructionTemplate
     */
    'tenant': string;
    /**
     * 
     * @type {InstructionTemplateIdentification}
     * @memberof InstructionTemplate
     */
    'identification'?: InstructionTemplateIdentification;
    /**
     * 
     * @type {string}
     * @memberof InstructionTemplate
     */
    'text': string;
    /**
     * If present, indicates to the preset whether the addressed driver shall acknowledge the receipt.
     * @type {boolean}
     * @memberof InstructionTemplate
     */
    'driverAcknowledgement'?: boolean;
}
/**
 * 
 * @export
 * @interface InstructionTemplateIdentification
 */
export interface InstructionTemplateIdentification {
    /**
     * 
     * @type {InstructionType}
     * @memberof InstructionTemplateIdentification
     */
    'type'?: InstructionType;
    /**
     * 
     * @type {string}
     * @memberof InstructionTemplateIdentification
     */
    'uid'?: string;
}


/**
 * 
 * @export
 * @interface InstructionTemplatesResponse
 */
export interface InstructionTemplatesResponse {
    /**
     * 
     * @type {InstructionTemplatesResponseData}
     * @memberof InstructionTemplatesResponse
     */
    'data'?: InstructionTemplatesResponseData;
}
/**
 * 
 * @export
 * @interface InstructionTemplatesResponseData
 */
export interface InstructionTemplatesResponseData {
    /**
     * 
     * @type {Array<InstructionTemplate>}
     * @memberof InstructionTemplatesResponseData
     */
    'predefinedTemplates'?: Array<InstructionTemplate>;
    /**
     * 
     * @type {Array<InstructionTemplate>}
     * @memberof InstructionTemplatesResponseData
     */
    'userDefinedTemplates'?: Array<InstructionTemplate>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const InstructionType = {
    Predefined: 'PREDEFINED',
    UserDefined: 'USER_DEFINED'
} as const;

export type InstructionType = typeof InstructionType[keyof typeof InstructionType];


/**
 * 
 * @export
 * @interface LineIdentification
 */
export interface LineIdentification {
    /**
     * 
     * @type {string}
     * @memberof LineIdentification
     */
    'uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof LineIdentification
     */
    'displayText'?: string;
}
/**
 * The \"result\" contains the result value of the modification to the object referenced by the given UID.
 * @export
 * @interface ModificationResult
 */
export interface ModificationResult {
    /**
     * The UID of modified object.
     * @type {string}
     * @memberof ModificationResult
     */
    'uid': string;
    /**
     * 
     * @type {Result}
     * @memberof ModificationResult
     */
    'result'?: Result;
    /**
     * A description why a modification failed. Is only present in case of a failure.
     * @type {string}
     * @memberof ModificationResult
     */
    'description'?: string;
}
/**
 * The response containing the result indicating which modifications in a bulk request were successful.
 * @export
 * @interface ModificationResultResponse
 */
export interface ModificationResultResponse {
    /**
     * If set to false, the whole operation succeeded. Otherwise, at least one item in property \'results\' has a result that describes an error.
     * @type {boolean}
     * @memberof ModificationResultResponse
     */
    'containsErrors'?: boolean;
    /**
     * For each object to be modified, an entry in the results list indicates if the modification was successfully applied.
     * @type {Array<ModificationResult>}
     * @memberof ModificationResultResponse
     */
    'results'?: Array<ModificationResult>;
}
/**
 * The properties \'identification\' and \'gpsPosition\' are required.
 * @export
 * @interface NetPoint
 */
export interface NetPoint {
    /**
     * 
     * @type {NetPointIdentification}
     * @memberof NetPoint
     */
    'identification'?: NetPointIdentification;
    /**
     * 
     * @type {StopIdentification}
     * @memberof NetPoint
     */
    'stop'?: StopIdentification;
    /**
     * 
     * @type {string}
     * @memberof NetPoint
     */
    'displayText'?: string;
    /**
     * 
     * @type {GpsPosition}
     * @memberof NetPoint
     */
    'gpsPosition'?: GpsPosition;
}
/**
 * 
 * @export
 * @interface NetPointIdentification
 */
export interface NetPointIdentification {
    /**
     * 
     * @type {NetPointType}
     * @memberof NetPointIdentification
     */
    'type'?: NetPointType;
    /**
     * 
     * @type {string}
     * @memberof NetPointIdentification
     */
    'uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof NetPointIdentification
     */
    'displayText'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const NetPointType = {
    StopPoint: 'STOP_POINT',
    DepotPoint: 'DEPOT_POINT',
    Beacon: 'BEACON',
    LinkPoint: 'LINK_POINT'
} as const;

export type NetPointType = typeof NetPointType[keyof typeof NetPointType];


/**
 * 
 * @export
 * @interface NetPointsResponse
 */
export interface NetPointsResponse {
    /**
     * 
     * @type {NetPointsResponseData}
     * @memberof NetPointsResponse
     */
    'data'?: NetPointsResponseData;
}
/**
 * 
 * @export
 * @interface NetPointsResponseData
 */
export interface NetPointsResponseData {
    /**
     * 
     * @type {Array<NetPoint>}
     * @memberof NetPointsResponseData
     */
    'stopPoints'?: Array<NetPoint>;
    /**
     * 
     * @type {Array<NetPoint>}
     * @memberof NetPointsResponseData
     */
    'depotPoints'?: Array<NetPoint>;
    /**
     * 
     * @type {Array<NetPoint>}
     * @memberof NetPointsResponseData
     */
    'beacons'?: Array<NetPoint>;
    /**
     * 
     * @type {Array<NetPoint>}
     * @memberof NetPointsResponseData
     */
    'linkPoints'?: Array<NetPoint>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const NotificationCategory = {
    Radio: 'RADIO',
    Disruption: 'DISRUPTION',
    VehicleDisruption: 'VEHICLE_DISRUPTION',
    ExternalDisruption: 'EXTERNAL_DISRUPTION'
} as const;

export type NotificationCategory = typeof NotificationCategory[keyof typeof NotificationCategory];


/**
 * 
 * @export
 * @enum {string}
 */

export const NotificationOrigin = {
    ControlCenter: 'CONTROL_CENTER',
    Vehicle: 'VEHICLE'
} as const;

export type NotificationOrigin = typeof NotificationOrigin[keyof typeof NotificationOrigin];


/**
 * 
 * @export
 * @interface Occupancy
 */
export interface Occupancy {
    /**
     * 
     * @type {Array<number>}
     * @memberof Occupancy
     */
    'range'?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof Occupancy
     */
    'passengerCount'?: number;
}
/**
 * Is the enumeration for the \'H\' column in the old client.
 * @export
 * @enum {string}
 */

export const OperationsLogCategory = {
    Call: 'CALL',
    DispatchAction: 'DISPATCH_ACTION',
    CallWithManualLogEntry: 'CALL_WITH_MANUAL_LOG_ENTRY',
    ManualLogEntry: 'MANUAL_LOG_ENTRY',
    Acknowledgment: 'ACKNOWLEDGMENT',
    Monitoring: 'MONITORING',
    AutoAcknowledgment: 'AUTO_ACKNOWLEDGMENT',
    EncodedInstruction: 'ENCODED_INSTRUCTION',
    FailedAction: 'FAILED_ACTION',
    TextInstruction: 'TEXT_INSTRUCTION',
    Jobmanagement: 'JOBMANAGEMENT',
    InitiatedByDriver: 'INITIATED_BY_DRIVER',
    ExternallyInitiated: 'EXTERNALLY_INITIATED',
    Empty: 'EMPTY'
} as const;

export type OperationsLogCategory = typeof OperationsLogCategory[keyof typeof OperationsLogCategory];


/**
 * A single entry of the operations log.
 * @export
 * @interface OperationsLogEntry
 */
export interface OperationsLogEntry {
    /**
     * Unique identifier for the entry.
     * @type {string}
     * @memberof OperationsLogEntry
     */
    'uid'?: string;
    /**
     * The timestamp for logging this entry, i.e. storing it in the operations log.
     * @type {string}
     * @memberof OperationsLogEntry
     */
    'logTimestamp'?: string;
    /**
     * The timestamp of the event. In case of a logged disruption report logTimestamp will be after this timestamp since the disruption report was created at the eventTimestamp and was moved to the operations log after acknowledgment. The timestamp of the acknowledgement matches the logTimestamp.
     * @type {string}
     * @memberof OperationsLogEntry
     */
    'eventTimestamp'?: string;
    /**
     * 
     * @type {OperationsLogCategory}
     * @memberof OperationsLogEntry
     */
    'category'?: OperationsLogCategory;
    /**
     * 
     * @type {string}
     * @memberof OperationsLogEntry
     */
    'tenant': string;
    /**
     * The text content of the operations log entry
     * @type {string}
     * @memberof OperationsLogEntry
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof OperationsLogEntry
     */
    'operatingDay'?: string;
    /**
     * 
     * @type {BlockIdentification}
     * @memberof OperationsLogEntry
     */
    'block'?: BlockIdentification;
    /**
     * 
     * @type {LineIdentification}
     * @memberof OperationsLogEntry
     */
    'line'?: LineIdentification;
    /**
     * 
     * @type {TripIdentification}
     * @memberof OperationsLogEntry
     */
    'trip'?: TripIdentification;
    /**
     * 
     * @type {VehicleIdentification}
     * @memberof OperationsLogEntry
     */
    'vehicle'?: VehicleIdentification;
    /**
     * voice radio ID of the vehicle
     * @type {string}
     * @memberof OperationsLogEntry
     */
    'voiceRadioId'?: string;
    /**
     * 
     * @type {Deviation}
     * @memberof OperationsLogEntry
     */
    'deviation'?: Deviation;
    /**
     * 
     * @type {DriverIdentification}
     * @memberof OperationsLogEntry
     */
    'driver'?: DriverIdentification;
    /**
     * 
     * @type {Occupancy}
     * @memberof OperationsLogEntry
     */
    'occupancy'?: Occupancy;
    /**
     * 
     * @type {Array<number>}
     * @memberof OperationsLogEntry
     */
    'trailers'?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof OperationsLogEntry
     */
    'remainingRange'?: number;
    /**
     * 
     * @type {number}
     * @memberof OperationsLogEntry
     */
    'stateOfCharge'?: number;
    /**
     * 
     * @type {Position}
     * @memberof OperationsLogEntry
     */
    'position'?: Position;
    /**
     * 
     * @type {Destination}
     * @memberof OperationsLogEntry
     */
    'destination'?: Destination;
    /**
     * 
     * @type {string}
     * @memberof OperationsLogEntry
     */
    'user': string;
    /**
     * Will be empty for the beginning.
     * @type {string}
     * @memberof OperationsLogEntry
     */
    'comment'?: string;
}


/**
 * A page of operations log entries including the data itself and information about the pagination.
 * @export
 * @interface OperationsLogPage
 */
export interface OperationsLogPage {
    /**
     * 
     * @type {number}
     * @memberof OperationsLogPage
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof OperationsLogPage
     */
    'offset'?: number;
    /**
     * The UID of the first entry in the data set being returned.
     * @type {number}
     * @memberof OperationsLogPage
     */
    'firstEntry'?: number;
    /**
     * The UID of the last entry in the data set being returned.
     * @type {number}
     * @memberof OperationsLogPage
     */
    'lastEntry'?: number;
    /**
     * 
     * @type {Array<OperationsLogEntry>}
     * @memberof OperationsLogPage
     */
    'data'?: Array<OperationsLogEntry>;
}
/**
 * 
 * @export
 * @interface PassengerDemand
 */
export interface PassengerDemand {
    /**
     * 
     * @type {DemandType}
     * @memberof PassengerDemand
     */
    'type'?: DemandType;
    /**
     * number of the de-boarding passengers
     * @type {number}
     * @memberof PassengerDemand
     */
    'deboardingCount'?: number;
    /**
     * The passenger groups that will be on-boarding
     * @type {Array<PassengerGroup>}
     * @memberof PassengerDemand
     */
    'onboardingPassengers'?: Array<PassengerGroup>;
}


/**
 * 
 * @export
 * @interface PassengerGroup
 */
export interface PassengerGroup {
    /**
     * 
     * @type {string}
     * @memberof PassengerGroup
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof PassengerGroup
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface Position
 */
export interface Position {
    /**
     * 
     * @type {string}
     * @memberof Position
     */
    'displayText'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Position
     */
    'stopNames'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PositionState
 */
export interface PositionState {
    /**
     * distance in per mill (of link between fromNetPoint and toNetPoint) measured from fromNetPoint
     * @type {number}
     * @memberof PositionState
     */
    'distance'?: number;
    /**
     * 
     * @type {TripItineraryNodeIdentification}
     * @memberof PositionState
     */
    'fromNetPoint'?: TripItineraryNodeIdentification;
    /**
     * 
     * @type {TripItineraryNodeIdentification}
     * @memberof PositionState
     */
    'toNetPoint'?: TripItineraryNodeIdentification;
}
/**
 * 
 * @export
 * @interface RadioMessage
 */
export interface RadioMessage {
    /**
     * 
     * @type {string}
     * @memberof RadioMessage
     */
    'uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof RadioMessage
     */
    'tenant'?: string;
    /**
     * 
     * @type {NotificationCategory}
     * @memberof RadioMessage
     */
    'category'?: NotificationCategory;
    /**
     * 
     * @type {string}
     * @memberof RadioMessage
     */
    'operatingDay'?: string;
    /**
     * 
     * @type {RadioMessageType}
     * @memberof RadioMessage
     */
    'type'?: RadioMessageType;
    /**
     * 
     * @type {number}
     * @memberof RadioMessage
     */
    'codedMessageId'?: number;
    /**
     * 
     * @type {string}
     * @memberof RadioMessage
     */
    'creationTime'?: string;
    /**
     * 
     * @type {NotificationOrigin}
     * @memberof RadioMessage
     */
    'origin'?: NotificationOrigin;
    /**
     * 
     * @type {string}
     * @memberof RadioMessage
     */
    'text'?: string;
    /**
     * 
     * @type {number}
     * @memberof RadioMessage
     */
    'priority'?: number;
    /**
     * 
     * @type {LineIdentification}
     * @memberof RadioMessage
     */
    'line'?: LineIdentification;
    /**
     * 
     * @type {Position}
     * @memberof RadioMessage
     */
    'position'?: Position;
    /**
     * 
     * @type {Destination}
     * @memberof RadioMessage
     */
    'destination'?: Destination;
    /**
     * 
     * @type {string}
     * @memberof RadioMessage
     */
    'user'?: string;
    /**
     * 
     * @type {VehicleIdentification}
     * @memberof RadioMessage
     */
    'vehicle'?: VehicleIdentification;
    /**
     * voice radio ID of the vehicle
     * @type {string}
     * @memberof RadioMessage
     */
    'voiceRadioId'?: string;
    /**
     * 
     * @type {Deviation}
     * @memberof RadioMessage
     */
    'deviation'?: Deviation;
    /**
     * 
     * @type {DriverIdentification}
     * @memberof RadioMessage
     */
    'driver'?: DriverIdentification;
    /**
     * 
     * @type {Occupancy}
     * @memberof RadioMessage
     */
    'occupancy'?: Occupancy;
    /**
     * 
     * @type {Array<number>}
     * @memberof RadioMessage
     */
    'trailers'?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof RadioMessage
     */
    'remainingRange'?: number;
    /**
     * 
     * @type {number}
     * @memberof RadioMessage
     */
    'stateOfCharge'?: number;
    /**
     * 
     * @type {BlockIdentification}
     * @memberof RadioMessage
     */
    'block'?: BlockIdentification;
    /**
     * 
     * @type {TripIdentification}
     * @memberof RadioMessage
     */
    'trip'?: TripIdentification;
}


/**
 * 
 * @export
 * @interface RadioMessageChange
 */
export interface RadioMessageChange {
    /**
     * 
     * @type {RadioMessage}
     * @memberof RadioMessageChange
     */
    'value': RadioMessage;
    /**
     * 
     * @type {ChangeType}
     * @memberof RadioMessageChange
     */
    'modifier': ChangeType;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const RadioMessageType = {
    EmergencyCall: 'EMERGENCY_CALL',
    IncidentCall: 'INCIDENT_CALL',
    PriorityCall: 'PRIORITY_CALL',
    ControlCenterCall: 'CONTROL_CENTER_CALL',
    CodedMessage: 'CODED_MESSAGE',
    CustomTextMessage: 'CUSTOM_TEXT_MESSAGE'
} as const;

export type RadioMessageType = typeof RadioMessageType[keyof typeof RadioMessageType];


/**
 * 
 * @export
 * @interface RadioMessagesAssignmentBody
 */
export interface RadioMessagesAssignmentBody {
    /**
     * 
     * @type {string}
     * @memberof RadioMessagesAssignmentBody
     */
    'user'?: string | null;
}
/**
 * 
 * @export
 * @interface RadioMessagesFilterSpec
 */
export interface RadioMessagesFilterSpec {
    /**
     * 
     * @type {Array<string>}
     * @memberof RadioMessagesFilterSpec
     */
    'tenant'?: Array<string>;
}
/**
 * 
 * @export
 * @interface RadioMessagesResponse
 */
export interface RadioMessagesResponse {
    /**
     * 
     * @type {Array<RadioMessage>}
     * @memberof RadioMessagesResponse
     */
    'data'?: Array<RadioMessage>;
}
/**
 * 
 * @export
 * @interface RadioMessagesSubscriptionRequestBody
 */
export interface RadioMessagesSubscriptionRequestBody {
    /**
     * 
     * @type {Array<RadioMessagesFilterSpec>}
     * @memberof RadioMessagesSubscriptionRequestBody
     */
    'filterKeys'?: Array<RadioMessagesFilterSpec>;
}
/**
 * 
 * @export
 * @interface RemainingTrips
 */
export interface RemainingTrips {
    /**
     * number of remaining trips for e-vehicles otherwise null
     * @type {number}
     * @memberof RemainingTrips
     */
    'predicted'?: number;
    /**
     * number of trips till the end of the block; current trip excluded
     * @type {number}
     * @memberof RemainingTrips
     */
    'target'?: number;
}
/**
 * Describes the result of an operation. If the value must be interpreted as error is defined in the property error (true).
 * @export
 * @interface Result
 */
export interface Result {
    /**
     * 
     * @type {ResultValue}
     * @memberof Result
     */
    'value'?: ResultValue;
    /**
     * 
     * @type {boolean}
     * @memberof Result
     */
    'error'?: boolean;
}


/**
 * The result of a single modification.
 * @export
 * @enum {string}
 */

export const ResultValue = {
    Ok: 'OK',
    Failed: 'FAILED',
    Unauthorized: 'UNAUTHORIZED',
    InvalidUid: 'INVALID_UID'
} as const;

export type ResultValue = typeof ResultValue[keyof typeof ResultValue];


/**
 * 
 * @export
 * @interface RouteIdentification
 */
export interface RouteIdentification {
    /**
     * 
     * @type {string}
     * @memberof RouteIdentification
     */
    'uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof RouteIdentification
     */
    'displayText'?: string;
}
/**
 * The operational data is present iff the registration state is OPERATIONAL or EXTERNAL. This does not necessarily hold for the sub values. They could be non-existing even if the operational data itself is present. For example, the driver data might not be present though the vehicle is operationally registered.
 * @export
 * @interface SelectableVehicle
 */
export interface SelectableVehicle {
    /**
     * 
     * @type {string}
     * @memberof SelectableVehicle
     */
    'tenant': string;
    /**
     * 
     * @type {VehicleIdentification}
     * @memberof SelectableVehicle
     */
    'identification': VehicleIdentification;
    /**
     * 
     * @type {string}
     * @memberof SelectableVehicle
     */
    'voiceRadioId'?: string;
    /**
     * 
     * @type {VehicleRegistrationState}
     * @memberof SelectableVehicle
     */
    'registrationState': VehicleRegistrationState;
    /**
     * 
     * @type {VehicleOperationalData}
     * @memberof SelectableVehicle
     */
    'operational'?: VehicleOperationalData;
    /**
     * 
     * @type {WorkingSetIdentification}
     * @memberof SelectableVehicle
     */
    'workingSet'?: WorkingSetIdentification;
    /**
     * 
     * @type {VehicleTypeIdentification}
     * @memberof SelectableVehicle
     */
    'type'?: VehicleTypeIdentification;
}


/**
 * 
 * @export
 * @interface SelectableVehiclesResponse
 */
export interface SelectableVehiclesResponse {
    /**
     * 
     * @type {Array<SelectableVehicle>}
     * @memberof SelectableVehiclesResponse
     */
    'data'?: Array<SelectableVehicle>;
}
/**
 * 
 * @export
 * @interface StopIdentification
 */
export interface StopIdentification {
    /**
     * 
     * @type {string}
     * @memberof StopIdentification
     */
    'uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof StopIdentification
     */
    'displayText'?: string;
}
/**
 * 
 * @export
 * @interface SubscriptionResponse
 */
export interface SubscriptionResponse {
    /**
     * 
     * @type {string}
     * @memberof SubscriptionResponse
     */
    'subscriptionId'?: string;
}
/**
 * An object representing a tenant.
 * @export
 * @interface Tenant
 */
export interface Tenant {
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    'displayText'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    'uid'?: string;
}
/**
 * An object providing a list of all available tenants in the data field.
 * @export
 * @interface TenantsResponse
 */
export interface TenantsResponse {
    /**
     * 
     * @type {Array<Tenant>}
     * @memberof TenantsResponse
     */
    'data'?: Array<Tenant>;
}
/**
 * The arrival and departure times of this itinerary\'s node. Only the pair of the planned times is always present. If the trip will begin soon, the actual time info will be present. The actual time info will start as a prediction of the times. After serving the node, it will switch to a logged timestamp.
 * @export
 * @interface TimeInfo
 */
export interface TimeInfo {
    /**
     * 
     * @type {ArrivalDepartureTime}
     * @memberof TimeInfo
     */
    'planned': ArrivalDepartureTime;
    /**
     * 
     * @type {ActualArrivalDepartureTimes}
     * @memberof TimeInfo
     */
    'actual'?: ActualArrivalDepartureTimes;
}
/**
 * Representation of a full trip.
 * @export
 * @interface Trip
 */
export interface Trip {
    /**
     * 
     * @type {BlockIdentification}
     * @memberof Trip
     */
    'block'?: BlockIdentification;
    /**
     * 
     * @type {LineIdentification}
     * @memberof Trip
     */
    'line'?: LineIdentification;
    /**
     * 
     * @type {TripItinerary}
     * @memberof Trip
     */
    'itinerary'?: TripItinerary;
    /**
     * 
     * @type {TripIdentification}
     * @memberof Trip
     */
    'identification': TripIdentification;
    /**
     * 
     * @type {string}
     * @memberof Trip
     */
    'operatingDay'?: string;
    /**
     * 
     * @type {string}
     * @memberof Trip
     */
    'destination'?: string;
    /**
     * 
     * @type {TripTimes}
     * @memberof Trip
     */
    'plannedTimes': TripTimes;
    /**
     * 
     * @type {ActualTripTimes}
     * @memberof Trip
     */
    'actualTimes'?: ActualTripTimes;
    /**
     * True iff the whole trip is cancelled.
     * @type {boolean}
     * @memberof Trip
     */
    'cancelled'?: boolean;
    /**
     * Contains a list of cancelled trip segments. If the property cancelled is set to true, a single segment containing the whole itinerary is given.
     * @type {Array<CancelledSegment>}
     * @memberof Trip
     */
    'cancelledSegments'?: Array<CancelledSegment>;
}
/**
 * 
 * @export
 * @interface TripIdentification
 */
export interface TripIdentification {
    /**
     * 
     * @type {string}
     * @memberof TripIdentification
     */
    'displayText'?: string;
    /**
     * 
     * @type {number}
     * @memberof TripIdentification
     */
    'numberInBlock'?: number;
    /**
     * 
     * @type {string}
     * @memberof TripIdentification
     */
    'uid'?: string;
}
/**
 * 
 * @export
 * @interface TripItinerariesFilterSpec
 */
export interface TripItinerariesFilterSpec {
    /**
     * 
     * @type {Array<string>}
     * @memberof TripItinerariesFilterSpec
     */
    'vehicleUid'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TripItinerariesFilterSpec
     */
    'blockUid'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TripItinerariesFilterSpec
     */
    'tripUid'?: Array<string>;
}
/**
 * 
 * @export
 * @interface TripItinerariesResponse
 */
export interface TripItinerariesResponse {
    /**
     * 
     * @type {Array<TripItinerary>}
     * @memberof TripItinerariesResponse
     */
    'data'?: Array<TripItinerary>;
}
/**
 * 
 * @export
 * @interface TripItinerariesSubscriptionRequestBody
 */
export interface TripItinerariesSubscriptionRequestBody {
    /**
     * 
     * @type {Array<TripItinerariesFilterSpec>}
     * @memberof TripItinerariesSubscriptionRequestBody
     */
    'filterKeys'?: Array<TripItinerariesFilterSpec>;
}
/**
 * A trip itinerary consists of a trip\'s route (i.e. its geographical route through the region) and trip specific information like the arrival and departure times and information about passenger demands, dispatching and so on. An itinerary mainly consists of its served links that are consisting of a start and an end node. Those nodes are associated to net points of the traffic network.
 * @export
 * @interface TripItinerary
 */
export interface TripItinerary {
    /**
     * 
     * @type {TripIdentification}
     * @memberof TripItinerary
     */
    'identification'?: TripIdentification;
    /**
     * 
     * @type {RouteIdentification}
     * @memberof TripItinerary
     */
    'route'?: RouteIdentification;
    /**
     * 
     * @type {Array<TripItineraryLink>}
     * @memberof TripItinerary
     */
    'links'?: Array<TripItineraryLink>;
}
/**
 * 
 * @export
 * @interface TripItineraryChange
 */
export interface TripItineraryChange {
    /**
     * 
     * @type {TripItinerary}
     * @memberof TripItineraryChange
     */
    'value': TripItinerary;
    /**
     * 
     * @type {ChangeType}
     * @memberof TripItineraryChange
     */
    'modifier': ChangeType;
}


/**
 * Link between the start and end node of the itinerary
 * @export
 * @interface TripItineraryLink
 */
export interface TripItineraryLink {
    /**
     * Length of the link in meters
     * @type {number}
     * @memberof TripItineraryLink
     */
    'length'?: number;
    /**
     * 
     * @type {TripItineraryNode}
     * @memberof TripItineraryLink
     */
    'start'?: TripItineraryNode;
    /**
     * 
     * @type {TripItineraryNode}
     * @memberof TripItineraryLink
     */
    'end'?: TripItineraryNode;
}
/**
 * This is a node of the itinerary. It describes a net point of our net. This node does not have to be associated to a stop point. The type of the underlying net point can be found in the \'identification\' property.
 * @export
 * @interface TripItineraryNode
 */
export interface TripItineraryNode {
    /**
     * 
     * @type {TripItineraryNodeIdentification}
     * @memberof TripItineraryNode
     */
    'identification'?: TripItineraryNodeIdentification;
    /**
     * 
     * @type {GpsPosition}
     * @memberof TripItineraryNode
     */
    'gpsPosition'?: GpsPosition;
    /**
     * 
     * @type {TimeInfo}
     * @memberof TripItineraryNode
     */
    'timeInfo'?: TimeInfo;
    /**
     * 
     * @type {boolean}
     * @memberof TripItineraryNode
     */
    'cancelled'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TripItineraryNode
     */
    'demandStop'?: boolean;
    /**
     * Is true iff the arrival and departure time are logged i.e. the vehicle actually arrived at (if it is not the very first node) and departed (if it is not the very last node) from this node.
     * @type {boolean}
     * @memberof TripItineraryNode
     */
    'wasServed'?: boolean;
    /**
     * 
     * @type {PassengerDemand}
     * @memberof TripItineraryNode
     */
    'passengerDemand'?: PassengerDemand;
    /**
     * 
     * @type {BehaviorAtStop}
     * @memberof TripItineraryNode
     */
    'behaviorAtStop'?: BehaviorAtStop;
}


/**
 * 
 * @export
 * @interface TripItineraryNodeIdentification
 */
export interface TripItineraryNodeIdentification {
    /**
     * 
     * @type {number}
     * @memberof TripItineraryNodeIdentification
     */
    'posInRoute'?: number;
    /**
     * 
     * @type {NetPointIdentification}
     * @memberof TripItineraryNodeIdentification
     */
    'netPoint'?: NetPointIdentification;
}
/**
 * 
 * @export
 * @interface TripTimes
 */
export interface TripTimes {
    /**
     * 
     * @type {string}
     * @memberof TripTimes
     */
    'start'?: string;
    /**
     * 
     * @type {string}
     * @memberof TripTimes
     */
    'end'?: string;
}
/**
 * 
 * @export
 * @interface VehicleIdentification
 */
export interface VehicleIdentification {
    /**
     * 
     * @type {string}
     * @memberof VehicleIdentification
     */
    'uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof VehicleIdentification
     */
    'displayText'?: string;
}
/**
 * 
 * @export
 * @interface VehicleOperationalData
 */
export interface VehicleOperationalData {
    /**
     * 
     * @type {LineIdentification}
     * @memberof VehicleOperationalData
     */
    'line'?: LineIdentification;
    /**
     * 
     * @type {BlockIdentification}
     * @memberof VehicleOperationalData
     */
    'block'?: BlockIdentification;
    /**
     * 
     * @type {TripIdentification}
     * @memberof VehicleOperationalData
     */
    'trip'?: TripIdentification;
    /**
     * 
     * @type {DriverIdentification}
     * @memberof VehicleOperationalData
     */
    'driver'?: DriverIdentification;
    /**
     * 
     * @type {DutyIdentification}
     * @memberof VehicleOperationalData
     */
    'duty'?: DutyIdentification;
    /**
     * 
     * @type {RouteIdentification}
     * @memberof VehicleOperationalData
     */
    'route'?: RouteIdentification;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const VehicleRegistrationState = {
    Unregistered: 'UNREGISTERED',
    Technical: 'TECHNICAL',
    Operational: 'OPERATIONAL',
    External: 'EXTERNAL'
} as const;

export type VehicleRegistrationState = typeof VehicleRegistrationState[keyof typeof VehicleRegistrationState];


/**
 * The operational data is present iff the registration state is OPERATIONAL or EXTERNAL. This does not necessarily hold for the sub values. They could be non-existing even if the operational data itself is present. For example, the driver data might not be present though the vehicle is operationally registered. Note that the value of the property registrationState of items in the response will never be UNREGISTERED as unregistered vehicles simply do not have a vehicle state.
 * @export
 * @interface VehicleState
 */
export interface VehicleState {
    /**
     * 
     * @type {string}
     * @memberof VehicleState
     */
    'tenant': string;
    /**
     * 
     * @type {VehicleIdentification}
     * @memberof VehicleState
     */
    'identification': VehicleIdentification;
    /**
     * 
     * @type {string}
     * @memberof VehicleState
     */
    'voiceRadioId'?: string;
    /**
     * 
     * @type {VehicleRegistrationState}
     * @memberof VehicleState
     */
    'registrationState': VehicleRegistrationState;
    /**
     * 
     * @type {VehicleOperationalData}
     * @memberof VehicleState
     */
    'operational'?: VehicleOperationalData;
    /**
     * 
     * @type {WorkingSetIdentification}
     * @memberof VehicleState
     */
    'workingSet'?: WorkingSetIdentification;
    /**
     * 
     * @type {VehicleTypeIdentification}
     * @memberof VehicleState
     */
    'type'?: VehicleTypeIdentification;
    /**
     * 
     * @type {string}
     * @memberof VehicleState
     */
    'lastUpdate': string;
    /**
     * 
     * @type {Deviation}
     * @memberof VehicleState
     */
    'deviation'?: Deviation;
    /**
     * 
     * @type {GpsPosition}
     * @memberof VehicleState
     */
    'gpsPosition'?: GpsPosition;
    /**
     * 
     * @type {GeoDirection}
     * @memberof VehicleState
     */
    'geoDirection'?: GeoDirection;
    /**
     * 
     * @type {PositionState}
     * @memberof VehicleState
     */
    'positionState'?: PositionState;
    /**
     * 
     * @type {Position}
     * @memberof VehicleState
     */
    'position'?: Position;
    /**
     * 
     * @type {Destination}
     * @memberof VehicleState
     */
    'destination'?: Destination;
    /**
     * 
     * @type {Occupancy}
     * @memberof VehicleState
     */
    'occupancy'?: Occupancy;
    /**
     * 
     * @type {Array<number>}
     * @memberof VehicleState
     */
    'trailers'?: Array<number>;
    /**
     * 
     * @type {number}
     * @memberof VehicleState
     */
    'remainingRange'?: number;
    /**
     * 
     * @type {number}
     * @memberof VehicleState
     */
    'stateOfCharge'?: number;
    /**
     * 
     * @type {RemainingTrips}
     * @memberof VehicleState
     */
    'remainingTrips'?: RemainingTrips;
    /**
     * speed in m per h (to allow for up to 3 positions after decimal point)
     * @type {number}
     * @memberof VehicleState
     */
    'speed'?: number;
}


/**
 * 
 * @export
 * @interface VehicleStateChange
 */
export interface VehicleStateChange {
    /**
     * 
     * @type {VehicleState}
     * @memberof VehicleStateChange
     */
    'value': VehicleState;
    /**
     * 
     * @type {ChangeType}
     * @memberof VehicleStateChange
     */
    'modifier': ChangeType;
}


/**
 * 
 * @export
 * @interface VehicleStatesFilterSpec
 */
export interface VehicleStatesFilterSpec {
    /**
     * 
     * @type {Array<string>}
     * @memberof VehicleStatesFilterSpec
     */
    'tenant'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof VehicleStatesFilterSpec
     */
    'vehicleUid'?: Array<string>;
}
/**
 * 
 * @export
 * @interface VehicleStatesResponse
 */
export interface VehicleStatesResponse {
    /**
     * 
     * @type {Array<VehicleState>}
     * @memberof VehicleStatesResponse
     */
    'data'?: Array<VehicleState>;
}
/**
 * 
 * @export
 * @interface VehicleStatesSubscriptionRequestBody
 */
export interface VehicleStatesSubscriptionRequestBody {
    /**
     * 
     * @type {Array<VehicleStatesFilterSpec>}
     * @memberof VehicleStatesSubscriptionRequestBody
     */
    'filterKeys'?: Array<VehicleStatesFilterSpec>;
}
/**
 * 
 * @export
 * @interface VehicleTypeIdentification
 */
export interface VehicleTypeIdentification {
    /**
     * 
     * @type {string}
     * @memberof VehicleTypeIdentification
     */
    'uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof VehicleTypeIdentification
     */
    'displayText'?: string;
}
/**
 * 
 * @export
 * @interface WorkingSetIdentification
 */
export interface WorkingSetIdentification {
    /**
     * 
     * @type {string}
     * @memberof WorkingSetIdentification
     */
    'uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkingSetIdentification
     */
    'displayText'?: string;
}

/**
 * BlocksApi - axios parameter creator
 * @export
 */
export const BlocksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a condensed view of the blocks matching the given query parameters. If a vehicle is registered but not currently serving a block, it won\'t appear in the result. Thus, the result might come back empty.
         * @param {string} acceptLanguage The language and region identifier of the requested language in IETF BCP 47 format. If none is present, the default language will be used.
         * @param {Array<string>} [vehicleUid] The UIDs of the vehicles to return the currently associated blocks for.
         * @param {Array<string>} [blockUid] The UIDs of the blocks that should be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCondensedBlocks: async (acceptLanguage: string, vehicleUid?: Array<string>, blockUid?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'acceptLanguage' is not null or undefined
            assertParamExists('retrieveCondensedBlocks', 'acceptLanguage', acceptLanguage)
            const localVarPath = `/gw/blocks/condensed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (vehicleUid) {
                localVarQueryParameter['vehicleUid'] = vehicleUid;
            }

            if (blockUid) {
                localVarQueryParameter['blockUid'] = blockUid;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlocksApi - functional programming interface
 * @export
 */
export const BlocksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BlocksApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a condensed view of the blocks matching the given query parameters. If a vehicle is registered but not currently serving a block, it won\'t appear in the result. Thus, the result might come back empty.
         * @param {string} acceptLanguage The language and region identifier of the requested language in IETF BCP 47 format. If none is present, the default language will be used.
         * @param {Array<string>} [vehicleUid] The UIDs of the vehicles to return the currently associated blocks for.
         * @param {Array<string>} [blockUid] The UIDs of the blocks that should be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveCondensedBlocks(acceptLanguage: string, vehicleUid?: Array<string>, blockUid?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CondensedBlocksResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveCondensedBlocks(acceptLanguage, vehicleUid, blockUid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BlocksApi - factory interface
 * @export
 */
export const BlocksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BlocksApiFp(configuration)
    return {
        /**
         * Retrieves a condensed view of the blocks matching the given query parameters. If a vehicle is registered but not currently serving a block, it won\'t appear in the result. Thus, the result might come back empty.
         * @param {string} acceptLanguage The language and region identifier of the requested language in IETF BCP 47 format. If none is present, the default language will be used.
         * @param {Array<string>} [vehicleUid] The UIDs of the vehicles to return the currently associated blocks for.
         * @param {Array<string>} [blockUid] The UIDs of the blocks that should be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCondensedBlocks(acceptLanguage: string, vehicleUid?: Array<string>, blockUid?: Array<string>, options?: any): AxiosPromise<CondensedBlocksResponse> {
            return localVarFp.retrieveCondensedBlocks(acceptLanguage, vehicleUid, blockUid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BlocksApi - object-oriented interface
 * @export
 * @class BlocksApi
 * @extends {BaseAPI}
 */
export class BlocksApi extends BaseAPI {
    /**
     * Retrieves a condensed view of the blocks matching the given query parameters. If a vehicle is registered but not currently serving a block, it won\'t appear in the result. Thus, the result might come back empty.
     * @param {string} acceptLanguage The language and region identifier of the requested language in IETF BCP 47 format. If none is present, the default language will be used.
     * @param {Array<string>} [vehicleUid] The UIDs of the vehicles to return the currently associated blocks for.
     * @param {Array<string>} [blockUid] The UIDs of the blocks that should be returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlocksApi
     */
    public retrieveCondensedBlocks(acceptLanguage: string, vehicleUid?: Array<string>, blockUid?: Array<string>, options?: AxiosRequestConfig) {
        return BlocksApiFp(this.configuration).retrieveCondensedBlocks(acceptLanguage, vehicleUid, blockUid, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CommunicationApi - axios parameter creator
 * @export
 */
export const CommunicationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new user-defined instruction template.
         * @param {InstructionTemplate} instructionTemplate All readonly properties will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInstructionTemplate: async (instructionTemplate: InstructionTemplate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'instructionTemplate' is not null or undefined
            assertParamExists('createInstructionTemplate', 'instructionTemplate', instructionTemplate)
            const localVarPath = `/gw/instructionTemplates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(instructionTemplate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a single instruction template. The instruction template must be of type USER_DEFINED. Templates of other types cannot be deleted.
         * @param {string} uid UID of the instruction template to be deleted. Must contain the UID as provided in an InstructionTemplateIdentification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInstructionTemplate: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteInstructionTemplate', 'uid', uid)
            const localVarPath = `/gw/instructionTemplates`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replaces a user-defined instruction template.
         * @param {string} uid UID of the instruction template one wants to replace. Must contain the UID as provided in an InstructionTemplateIdentification.
         * @param {InstructionTemplate} instructionTemplate All readonly properties will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replacesInstructionTemplate: async (uid: string, instructionTemplate: InstructionTemplate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('replacesInstructionTemplate', 'uid', uid)
            // verify required parameter 'instructionTemplate' is not null or undefined
            assertParamExists('replacesInstructionTemplate', 'instructionTemplate', instructionTemplate)
            const localVarPath = `/gw/instructionTemplates`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(instructionTemplate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves data related to the instruction templates queried. The method shall be used with at least the tenant query parameter set (to a non-empty array). Note that currently, the contents of the response like the text property will be in the language which was used in the plan data.
         * @param {string} acceptLanguage The language and region identifier of the requested language in IETF BCP 47 format. If none is present, the default language will be used.
         * @param {Array<string>} [tenant] IDs of the tenants (short name)
         * @param {Array<InstructionType>} [type] Type of instruction (message). \&#39;PREDEFINED\&#39; stands for coded instructions predefined by the system, the templates for which cannot be altered. \&#39;USER_DEFINED\&#39; stands for custom text instructions defined by a user, the templates for which can be altered.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveInstructionTemplates: async (acceptLanguage: string, tenant?: Array<string>, type?: Array<InstructionType>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'acceptLanguage' is not null or undefined
            assertParamExists('retrieveInstructionTemplates', 'acceptLanguage', acceptLanguage)
            const localVarPath = `/gw/instructionTemplates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tenant) {
                localVarQueryParameter['tenant'] = tenant.join(COLLECTION_FORMATS.csv);
            }

            if (type) {
                localVarQueryParameter['type'] = type;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends an instruction (predefined or user-defined instruction). The request must at least contain the UID of a predefined instruction if the request is of type \'PREDEFINED\'. If the request is of type \'USER_DEFINED\', then wanting to use a template and not changing the text can be expressed by using the uid of the desired template. The other cases of type \'USER_DEFINED\' shall set the text property. The text will not be internationalized and will be presented to every user as it was given, independently of an individual user\'s language.
         * @param {Instruction} [instruction] All readonly properties will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInstruction: async (instruction?: Instruction, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/gw/instructions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(instruction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommunicationApi - functional programming interface
 * @export
 */
export const CommunicationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CommunicationApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new user-defined instruction template.
         * @param {InstructionTemplate} instructionTemplate All readonly properties will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInstructionTemplate(instructionTemplate: InstructionTemplate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstructionTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInstructionTemplate(instructionTemplate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a single instruction template. The instruction template must be of type USER_DEFINED. Templates of other types cannot be deleted.
         * @param {string} uid UID of the instruction template to be deleted. Must contain the UID as provided in an InstructionTemplateIdentification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteInstructionTemplate(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteInstructionTemplate(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replaces a user-defined instruction template.
         * @param {string} uid UID of the instruction template one wants to replace. Must contain the UID as provided in an InstructionTemplateIdentification.
         * @param {InstructionTemplate} instructionTemplate All readonly properties will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async replacesInstructionTemplate(uid: string, instructionTemplate: InstructionTemplate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstructionTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.replacesInstructionTemplate(uid, instructionTemplate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves data related to the instruction templates queried. The method shall be used with at least the tenant query parameter set (to a non-empty array). Note that currently, the contents of the response like the text property will be in the language which was used in the plan data.
         * @param {string} acceptLanguage The language and region identifier of the requested language in IETF BCP 47 format. If none is present, the default language will be used.
         * @param {Array<string>} [tenant] IDs of the tenants (short name)
         * @param {Array<InstructionType>} [type] Type of instruction (message). \&#39;PREDEFINED\&#39; stands for coded instructions predefined by the system, the templates for which cannot be altered. \&#39;USER_DEFINED\&#39; stands for custom text instructions defined by a user, the templates for which can be altered.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveInstructionTemplates(acceptLanguage: string, tenant?: Array<string>, type?: Array<InstructionType>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InstructionTemplatesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveInstructionTemplates(acceptLanguage, tenant, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Sends an instruction (predefined or user-defined instruction). The request must at least contain the UID of a predefined instruction if the request is of type \'PREDEFINED\'. If the request is of type \'USER_DEFINED\', then wanting to use a template and not changing the text can be expressed by using the uid of the desired template. The other cases of type \'USER_DEFINED\' shall set the text property. The text will not be internationalized and will be presented to every user as it was given, independently of an individual user\'s language.
         * @param {Instruction} [instruction] All readonly properties will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendInstruction(instruction?: Instruction, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Instruction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendInstruction(instruction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CommunicationApi - factory interface
 * @export
 */
export const CommunicationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CommunicationApiFp(configuration)
    return {
        /**
         * Creates a new user-defined instruction template.
         * @param {InstructionTemplate} instructionTemplate All readonly properties will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInstructionTemplate(instructionTemplate: InstructionTemplate, options?: any): AxiosPromise<InstructionTemplate> {
            return localVarFp.createInstructionTemplate(instructionTemplate, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a single instruction template. The instruction template must be of type USER_DEFINED. Templates of other types cannot be deleted.
         * @param {string} uid UID of the instruction template to be deleted. Must contain the UID as provided in an InstructionTemplateIdentification.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInstructionTemplate(uid: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteInstructionTemplate(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Replaces a user-defined instruction template.
         * @param {string} uid UID of the instruction template one wants to replace. Must contain the UID as provided in an InstructionTemplateIdentification.
         * @param {InstructionTemplate} instructionTemplate All readonly properties will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replacesInstructionTemplate(uid: string, instructionTemplate: InstructionTemplate, options?: any): AxiosPromise<InstructionTemplate> {
            return localVarFp.replacesInstructionTemplate(uid, instructionTemplate, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves data related to the instruction templates queried. The method shall be used with at least the tenant query parameter set (to a non-empty array). Note that currently, the contents of the response like the text property will be in the language which was used in the plan data.
         * @param {string} acceptLanguage The language and region identifier of the requested language in IETF BCP 47 format. If none is present, the default language will be used.
         * @param {Array<string>} [tenant] IDs of the tenants (short name)
         * @param {Array<InstructionType>} [type] Type of instruction (message). \&#39;PREDEFINED\&#39; stands for coded instructions predefined by the system, the templates for which cannot be altered. \&#39;USER_DEFINED\&#39; stands for custom text instructions defined by a user, the templates for which can be altered.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveInstructionTemplates(acceptLanguage: string, tenant?: Array<string>, type?: Array<InstructionType>, options?: any): AxiosPromise<InstructionTemplatesResponse> {
            return localVarFp.retrieveInstructionTemplates(acceptLanguage, tenant, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends an instruction (predefined or user-defined instruction). The request must at least contain the UID of a predefined instruction if the request is of type \'PREDEFINED\'. If the request is of type \'USER_DEFINED\', then wanting to use a template and not changing the text can be expressed by using the uid of the desired template. The other cases of type \'USER_DEFINED\' shall set the text property. The text will not be internationalized and will be presented to every user as it was given, independently of an individual user\'s language.
         * @param {Instruction} [instruction] All readonly properties will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInstruction(instruction?: Instruction, options?: any): AxiosPromise<Instruction> {
            return localVarFp.sendInstruction(instruction, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CommunicationApi - object-oriented interface
 * @export
 * @class CommunicationApi
 * @extends {BaseAPI}
 */
export class CommunicationApi extends BaseAPI {
    /**
     * Creates a new user-defined instruction template.
     * @param {InstructionTemplate} instructionTemplate All readonly properties will be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommunicationApi
     */
    public createInstructionTemplate(instructionTemplate: InstructionTemplate, options?: AxiosRequestConfig) {
        return CommunicationApiFp(this.configuration).createInstructionTemplate(instructionTemplate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a single instruction template. The instruction template must be of type USER_DEFINED. Templates of other types cannot be deleted.
     * @param {string} uid UID of the instruction template to be deleted. Must contain the UID as provided in an InstructionTemplateIdentification.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommunicationApi
     */
    public deleteInstructionTemplate(uid: string, options?: AxiosRequestConfig) {
        return CommunicationApiFp(this.configuration).deleteInstructionTemplate(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replaces a user-defined instruction template.
     * @param {string} uid UID of the instruction template one wants to replace. Must contain the UID as provided in an InstructionTemplateIdentification.
     * @param {InstructionTemplate} instructionTemplate All readonly properties will be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommunicationApi
     */
    public replacesInstructionTemplate(uid: string, instructionTemplate: InstructionTemplate, options?: AxiosRequestConfig) {
        return CommunicationApiFp(this.configuration).replacesInstructionTemplate(uid, instructionTemplate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves data related to the instruction templates queried. The method shall be used with at least the tenant query parameter set (to a non-empty array). Note that currently, the contents of the response like the text property will be in the language which was used in the plan data.
     * @param {string} acceptLanguage The language and region identifier of the requested language in IETF BCP 47 format. If none is present, the default language will be used.
     * @param {Array<string>} [tenant] IDs of the tenants (short name)
     * @param {Array<InstructionType>} [type] Type of instruction (message). \&#39;PREDEFINED\&#39; stands for coded instructions predefined by the system, the templates for which cannot be altered. \&#39;USER_DEFINED\&#39; stands for custom text instructions defined by a user, the templates for which can be altered.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommunicationApi
     */
    public retrieveInstructionTemplates(acceptLanguage: string, tenant?: Array<string>, type?: Array<InstructionType>, options?: AxiosRequestConfig) {
        return CommunicationApiFp(this.configuration).retrieveInstructionTemplates(acceptLanguage, tenant, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sends an instruction (predefined or user-defined instruction). The request must at least contain the UID of a predefined instruction if the request is of type \'PREDEFINED\'. If the request is of type \'USER_DEFINED\', then wanting to use a template and not changing the text can be expressed by using the uid of the desired template. The other cases of type \'USER_DEFINED\' shall set the text property. The text will not be internationalized and will be presented to every user as it was given, independently of an individual user\'s language.
     * @param {Instruction} [instruction] All readonly properties will be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommunicationApi
     */
    public sendInstruction(instruction?: Instruction, options?: AxiosRequestConfig) {
        return CommunicationApiFp(this.configuration).sendInstruction(instruction, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DisruptionReportsApi - axios parameter creator
 * @export
 */
export const DisruptionReportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Method to acknowledge i.e. delete disruption reports.
         * @param {Array<string>} uid UIDs of the disruption reports
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acknowledgeDisruptionReport: async (uid: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('acknowledgeDisruptionReport', 'uid', uid)
            const localVarPath = `/gw/disruptionReports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (uid) {
                localVarQueryParameter['uid'] = uid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Method to assign a disruption report to a user or unassign to no one.
         * @param {Array<string>} uid UIDs of the disruption reports
         * @param {DisruptionReportsAssignmentBody} disruptionReportsAssignmentBody Information about the user to be assigned to. If the user property is null, the user will be unassigned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignDisruptionReport: async (uid: Array<string>, disruptionReportsAssignmentBody: DisruptionReportsAssignmentBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('assignDisruptionReport', 'uid', uid)
            // verify required parameter 'disruptionReportsAssignmentBody' is not null or undefined
            assertParamExists('assignDisruptionReport', 'disruptionReportsAssignmentBody', disruptionReportsAssignmentBody)
            const localVarPath = `/gw/disruptionReports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (uid) {
                localVarQueryParameter['uid'] = uid;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(disruptionReportsAssignmentBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all currently available disruption reports.
         * @param {string} acceptLanguage The language and region identifier of the requested language in IETF BCP 47 format. If none is present, the default language will be used.
         * @param {Array<string>} [tenant] IDs of the tenants (short name)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDisruptionReports: async (acceptLanguage: string, tenant?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'acceptLanguage' is not null or undefined
            assertParamExists('retrieveDisruptionReports', 'acceptLanguage', acceptLanguage)
            const localVarPath = `/gw/disruptionReports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tenant) {
                localVarQueryParameter['tenant'] = tenant.join(COLLECTION_FORMATS.csv);
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DisruptionReportsApi - functional programming interface
 * @export
 */
export const DisruptionReportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DisruptionReportsApiAxiosParamCreator(configuration)
    return {
        /**
         * Method to acknowledge i.e. delete disruption reports.
         * @param {Array<string>} uid UIDs of the disruption reports
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acknowledgeDisruptionReport(uid: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModificationResultResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acknowledgeDisruptionReport(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Method to assign a disruption report to a user or unassign to no one.
         * @param {Array<string>} uid UIDs of the disruption reports
         * @param {DisruptionReportsAssignmentBody} disruptionReportsAssignmentBody Information about the user to be assigned to. If the user property is null, the user will be unassigned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignDisruptionReport(uid: Array<string>, disruptionReportsAssignmentBody: DisruptionReportsAssignmentBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModificationResultResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignDisruptionReport(uid, disruptionReportsAssignmentBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all currently available disruption reports.
         * @param {string} acceptLanguage The language and region identifier of the requested language in IETF BCP 47 format. If none is present, the default language will be used.
         * @param {Array<string>} [tenant] IDs of the tenants (short name)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveDisruptionReports(acceptLanguage: string, tenant?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DisruptionReportsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveDisruptionReports(acceptLanguage, tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DisruptionReportsApi - factory interface
 * @export
 */
export const DisruptionReportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DisruptionReportsApiFp(configuration)
    return {
        /**
         * Method to acknowledge i.e. delete disruption reports.
         * @param {Array<string>} uid UIDs of the disruption reports
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acknowledgeDisruptionReport(uid: Array<string>, options?: any): AxiosPromise<ModificationResultResponse> {
            return localVarFp.acknowledgeDisruptionReport(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Method to assign a disruption report to a user or unassign to no one.
         * @param {Array<string>} uid UIDs of the disruption reports
         * @param {DisruptionReportsAssignmentBody} disruptionReportsAssignmentBody Information about the user to be assigned to. If the user property is null, the user will be unassigned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignDisruptionReport(uid: Array<string>, disruptionReportsAssignmentBody: DisruptionReportsAssignmentBody, options?: any): AxiosPromise<ModificationResultResponse> {
            return localVarFp.assignDisruptionReport(uid, disruptionReportsAssignmentBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all currently available disruption reports.
         * @param {string} acceptLanguage The language and region identifier of the requested language in IETF BCP 47 format. If none is present, the default language will be used.
         * @param {Array<string>} [tenant] IDs of the tenants (short name)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDisruptionReports(acceptLanguage: string, tenant?: Array<string>, options?: any): AxiosPromise<DisruptionReportsResponse> {
            return localVarFp.retrieveDisruptionReports(acceptLanguage, tenant, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DisruptionReportsApi - object-oriented interface
 * @export
 * @class DisruptionReportsApi
 * @extends {BaseAPI}
 */
export class DisruptionReportsApi extends BaseAPI {
    /**
     * Method to acknowledge i.e. delete disruption reports.
     * @param {Array<string>} uid UIDs of the disruption reports
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisruptionReportsApi
     */
    public acknowledgeDisruptionReport(uid: Array<string>, options?: AxiosRequestConfig) {
        return DisruptionReportsApiFp(this.configuration).acknowledgeDisruptionReport(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Method to assign a disruption report to a user or unassign to no one.
     * @param {Array<string>} uid UIDs of the disruption reports
     * @param {DisruptionReportsAssignmentBody} disruptionReportsAssignmentBody Information about the user to be assigned to. If the user property is null, the user will be unassigned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisruptionReportsApi
     */
    public assignDisruptionReport(uid: Array<string>, disruptionReportsAssignmentBody: DisruptionReportsAssignmentBody, options?: AxiosRequestConfig) {
        return DisruptionReportsApiFp(this.configuration).assignDisruptionReport(uid, disruptionReportsAssignmentBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all currently available disruption reports.
     * @param {string} acceptLanguage The language and region identifier of the requested language in IETF BCP 47 format. If none is present, the default language will be used.
     * @param {Array<string>} [tenant] IDs of the tenants (short name)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DisruptionReportsApi
     */
    public retrieveDisruptionReports(acceptLanguage: string, tenant?: Array<string>, options?: AxiosRequestConfig) {
        return DisruptionReportsApiFp(this.configuration).retrieveDisruptionReports(acceptLanguage, tenant, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns all currently available events matching the query parameter criteria.
         * @param {string} vehicleUid The UID of the vehicle to return the currently associated events for.
         * @param {string} acceptLanguage The language and region identifier of the requested language in IETF BCP 47 format. If none is present, the default language will be used.
         * @param {string} [timeFrameStart] The beginning of the time frame to query events from. The time frame condition is applied to the point in time an event was created / began to exist. If this parameter is not provided by the client a default value is used. Must be provided as ISO 8601-1 string.
         * @param {string} [timeFrameEnd] The end of the time frame to query events from. The time frame condition is applied to the point in time an event was created / began to exist. If this parameter is not provided by the client it defaults to the current time (now). Must be provided as ISO 8601-1 string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveEvents: async (vehicleUid: string, acceptLanguage: string, timeFrameStart?: string, timeFrameEnd?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vehicleUid' is not null or undefined
            assertParamExists('retrieveEvents', 'vehicleUid', vehicleUid)
            // verify required parameter 'acceptLanguage' is not null or undefined
            assertParamExists('retrieveEvents', 'acceptLanguage', acceptLanguage)
            const localVarPath = `/gw/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (vehicleUid !== undefined) {
                localVarQueryParameter['vehicleUid'] = vehicleUid;
            }

            if (timeFrameStart !== undefined) {
                localVarQueryParameter['timeFrameStart'] = timeFrameStart;
            }

            if (timeFrameEnd !== undefined) {
                localVarQueryParameter['timeFrameEnd'] = timeFrameEnd;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns all currently available events matching the query parameter criteria.
         * @param {string} vehicleUid The UID of the vehicle to return the currently associated events for.
         * @param {string} acceptLanguage The language and region identifier of the requested language in IETF BCP 47 format. If none is present, the default language will be used.
         * @param {string} [timeFrameStart] The beginning of the time frame to query events from. The time frame condition is applied to the point in time an event was created / began to exist. If this parameter is not provided by the client a default value is used. Must be provided as ISO 8601-1 string.
         * @param {string} [timeFrameEnd] The end of the time frame to query events from. The time frame condition is applied to the point in time an event was created / began to exist. If this parameter is not provided by the client it defaults to the current time (now). Must be provided as ISO 8601-1 string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveEvents(vehicleUid: string, acceptLanguage: string, timeFrameStart?: string, timeFrameEnd?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveEvents(vehicleUid, acceptLanguage, timeFrameStart, timeFrameEnd, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         * Returns all currently available events matching the query parameter criteria.
         * @param {string} vehicleUid The UID of the vehicle to return the currently associated events for.
         * @param {string} acceptLanguage The language and region identifier of the requested language in IETF BCP 47 format. If none is present, the default language will be used.
         * @param {string} [timeFrameStart] The beginning of the time frame to query events from. The time frame condition is applied to the point in time an event was created / began to exist. If this parameter is not provided by the client a default value is used. Must be provided as ISO 8601-1 string.
         * @param {string} [timeFrameEnd] The end of the time frame to query events from. The time frame condition is applied to the point in time an event was created / began to exist. If this parameter is not provided by the client it defaults to the current time (now). Must be provided as ISO 8601-1 string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveEvents(vehicleUid: string, acceptLanguage: string, timeFrameStart?: string, timeFrameEnd?: string, options?: any): AxiosPromise<EventsResponse> {
            return localVarFp.retrieveEvents(vehicleUid, acceptLanguage, timeFrameStart, timeFrameEnd, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * Returns all currently available events matching the query parameter criteria.
     * @param {string} vehicleUid The UID of the vehicle to return the currently associated events for.
     * @param {string} acceptLanguage The language and region identifier of the requested language in IETF BCP 47 format. If none is present, the default language will be used.
     * @param {string} [timeFrameStart] The beginning of the time frame to query events from. The time frame condition is applied to the point in time an event was created / began to exist. If this parameter is not provided by the client a default value is used. Must be provided as ISO 8601-1 string.
     * @param {string} [timeFrameEnd] The end of the time frame to query events from. The time frame condition is applied to the point in time an event was created / began to exist. If this parameter is not provided by the client it defaults to the current time (now). Must be provided as ISO 8601-1 string.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public retrieveEvents(vehicleUid: string, acceptLanguage: string, timeFrameStart?: string, timeFrameEnd?: string, options?: AxiosRequestConfig) {
        return EventsApiFp(this.configuration).retrieveEvents(vehicleUid, acceptLanguage, timeFrameStart, timeFrameEnd, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NetPointsApi - axios parameter creator
 * @export
 */
export const NetPointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves net points of the given tenant. Only one of the query parameters \'tenant\' or \'lineUid\' may be used at the same time. They are mutually exclusive.
         * @param {Array<string>} [tenant] IDs of the tenants (short name)
         * @param {Array<NetPointType>} [type] Type of net point.
         * @param {Array<string>} [lineUid] UIDs of lines. If this query parameter is used, only net points of the desired types that are used on routes (both planned and those dynamically created through dispatching) of the referenced lines will be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveNetPoints: async (tenant?: Array<string>, type?: Array<NetPointType>, lineUid?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/gw/netPoints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tenant) {
                localVarQueryParameter['tenant'] = tenant.join(COLLECTION_FORMATS.csv);
            }

            if (type) {
                localVarQueryParameter['type'] = type;
            }

            if (lineUid) {
                localVarQueryParameter['lineUid'] = lineUid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NetPointsApi - functional programming interface
 * @export
 */
export const NetPointsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NetPointsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves net points of the given tenant. Only one of the query parameters \'tenant\' or \'lineUid\' may be used at the same time. They are mutually exclusive.
         * @param {Array<string>} [tenant] IDs of the tenants (short name)
         * @param {Array<NetPointType>} [type] Type of net point.
         * @param {Array<string>} [lineUid] UIDs of lines. If this query parameter is used, only net points of the desired types that are used on routes (both planned and those dynamically created through dispatching) of the referenced lines will be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveNetPoints(tenant?: Array<string>, type?: Array<NetPointType>, lineUid?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetPointsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveNetPoints(tenant, type, lineUid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NetPointsApi - factory interface
 * @export
 */
export const NetPointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NetPointsApiFp(configuration)
    return {
        /**
         * Retrieves net points of the given tenant. Only one of the query parameters \'tenant\' or \'lineUid\' may be used at the same time. They are mutually exclusive.
         * @param {Array<string>} [tenant] IDs of the tenants (short name)
         * @param {Array<NetPointType>} [type] Type of net point.
         * @param {Array<string>} [lineUid] UIDs of lines. If this query parameter is used, only net points of the desired types that are used on routes (both planned and those dynamically created through dispatching) of the referenced lines will be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveNetPoints(tenant?: Array<string>, type?: Array<NetPointType>, lineUid?: Array<string>, options?: any): AxiosPromise<NetPointsResponse> {
            return localVarFp.retrieveNetPoints(tenant, type, lineUid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NetPointsApi - object-oriented interface
 * @export
 * @class NetPointsApi
 * @extends {BaseAPI}
 */
export class NetPointsApi extends BaseAPI {
    /**
     * Retrieves net points of the given tenant. Only one of the query parameters \'tenant\' or \'lineUid\' may be used at the same time. They are mutually exclusive.
     * @param {Array<string>} [tenant] IDs of the tenants (short name)
     * @param {Array<NetPointType>} [type] Type of net point.
     * @param {Array<string>} [lineUid] UIDs of lines. If this query parameter is used, only net points of the desired types that are used on routes (both planned and those dynamically created through dispatching) of the referenced lines will be returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetPointsApi
     */
    public retrieveNetPoints(tenant?: Array<string>, type?: Array<NetPointType>, lineUid?: Array<string>, options?: AxiosRequestConfig) {
        return NetPointsApiFp(this.configuration).retrieveNetPoints(tenant, type, lineUid, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OperationsLogsApi - axios parameter creator
 * @export
 */
export const OperationsLogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new operations log entry. The entry must at least contain a text, a tenant and the user. If the new entry shall be associated to a vehicle, then the property vehicle->uid shall be set. The text will not be internationalized. It will be presented to every user as it was specified independently of the user\'s language.
         * @param {OperationsLogEntry} [operationsLogEntry] All readonly properties will be ignored. Furthermore, all referenced objects except for the VehicleIdentification (so it can be used to provide the UID of a vehicle) will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOperationsLogEntry: async (operationsLogEntry?: OperationsLogEntry, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/gw/operationsLogs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(operationsLogEntry, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all the currently available operations log entries sorted by logTimestamp in descending order.
         * @param {number} limit Maximum number of operations log entries in the response
         * @param {string} acceptLanguage The language and region identifier of the requested language in IETF BCP 47 format. If none is present, the default language will be used.
         * @param {Array<string>} [tenant] IDs of the tenants (short name)
         * @param {number} [offset] The offset of the entries. The entries are sorted by log timestamp. E.g. an offset of 100 omits the first 100 most recent entries.
         * @param {string} [lastEntry] The id of the last entry that was already loaded by the client of this API. The entries \&#39;after\&#39; this entry will be returned. Hence, it can be used to load a page \&#39;after\&#39; an already loaded one.
         * @param {string} [firstEntry] The id of the first entry that was already loaded by the client of this API. The entries \&#39;before\&#39; this entry will be returned. Hence, it can be used to load a page \&#39;before\&#39; an already loaded one.
         * @param {string} [timeFrameStart] The beginning of the time frame to query operations logs from. The time frame condition is applied to the point in time an operations log entry was last modified at. If this parameter is not provided by the client it defaults to the start of the current day. Must be provided as ISO 8601-1 string.
         * @param {string} [timeFrameEnd] The end of the time frame to query operations logs from. The time frame condition is applied to the point in time an operations log entry was last modified at. If this parameter is not provided by the client it defaults the current time (now). Must be provided as ISO 8601-1 string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveOperationsLogs: async (limit: number, acceptLanguage: string, tenant?: Array<string>, offset?: number, lastEntry?: string, firstEntry?: string, timeFrameStart?: string, timeFrameEnd?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('retrieveOperationsLogs', 'limit', limit)
            // verify required parameter 'acceptLanguage' is not null or undefined
            assertParamExists('retrieveOperationsLogs', 'acceptLanguage', acceptLanguage)
            const localVarPath = `/gw/operationsLogs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tenant) {
                localVarQueryParameter['tenant'] = tenant.join(COLLECTION_FORMATS.csv);
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (lastEntry !== undefined) {
                localVarQueryParameter['lastEntry'] = lastEntry;
            }

            if (firstEntry !== undefined) {
                localVarQueryParameter['firstEntry'] = firstEntry;
            }

            if (timeFrameStart !== undefined) {
                localVarQueryParameter['timeFrameStart'] = timeFrameStart;
            }

            if (timeFrameEnd !== undefined) {
                localVarQueryParameter['timeFrameEnd'] = timeFrameEnd;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OperationsLogsApi - functional programming interface
 * @export
 */
export const OperationsLogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OperationsLogsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new operations log entry. The entry must at least contain a text, a tenant and the user. If the new entry shall be associated to a vehicle, then the property vehicle->uid shall be set. The text will not be internationalized. It will be presented to every user as it was specified independently of the user\'s language.
         * @param {OperationsLogEntry} [operationsLogEntry] All readonly properties will be ignored. Furthermore, all referenced objects except for the VehicleIdentification (so it can be used to provide the UID of a vehicle) will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOperationsLogEntry(operationsLogEntry?: OperationsLogEntry, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationsLogEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOperationsLogEntry(operationsLogEntry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all the currently available operations log entries sorted by logTimestamp in descending order.
         * @param {number} limit Maximum number of operations log entries in the response
         * @param {string} acceptLanguage The language and region identifier of the requested language in IETF BCP 47 format. If none is present, the default language will be used.
         * @param {Array<string>} [tenant] IDs of the tenants (short name)
         * @param {number} [offset] The offset of the entries. The entries are sorted by log timestamp. E.g. an offset of 100 omits the first 100 most recent entries.
         * @param {string} [lastEntry] The id of the last entry that was already loaded by the client of this API. The entries \&#39;after\&#39; this entry will be returned. Hence, it can be used to load a page \&#39;after\&#39; an already loaded one.
         * @param {string} [firstEntry] The id of the first entry that was already loaded by the client of this API. The entries \&#39;before\&#39; this entry will be returned. Hence, it can be used to load a page \&#39;before\&#39; an already loaded one.
         * @param {string} [timeFrameStart] The beginning of the time frame to query operations logs from. The time frame condition is applied to the point in time an operations log entry was last modified at. If this parameter is not provided by the client it defaults to the start of the current day. Must be provided as ISO 8601-1 string.
         * @param {string} [timeFrameEnd] The end of the time frame to query operations logs from. The time frame condition is applied to the point in time an operations log entry was last modified at. If this parameter is not provided by the client it defaults the current time (now). Must be provided as ISO 8601-1 string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveOperationsLogs(limit: number, acceptLanguage: string, tenant?: Array<string>, offset?: number, lastEntry?: string, firstEntry?: string, timeFrameStart?: string, timeFrameEnd?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationsLogPage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveOperationsLogs(limit, acceptLanguage, tenant, offset, lastEntry, firstEntry, timeFrameStart, timeFrameEnd, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OperationsLogsApi - factory interface
 * @export
 */
export const OperationsLogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OperationsLogsApiFp(configuration)
    return {
        /**
         * Creates a new operations log entry. The entry must at least contain a text, a tenant and the user. If the new entry shall be associated to a vehicle, then the property vehicle->uid shall be set. The text will not be internationalized. It will be presented to every user as it was specified independently of the user\'s language.
         * @param {OperationsLogEntry} [operationsLogEntry] All readonly properties will be ignored. Furthermore, all referenced objects except for the VehicleIdentification (so it can be used to provide the UID of a vehicle) will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOperationsLogEntry(operationsLogEntry?: OperationsLogEntry, options?: any): AxiosPromise<OperationsLogEntry> {
            return localVarFp.createOperationsLogEntry(operationsLogEntry, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all the currently available operations log entries sorted by logTimestamp in descending order.
         * @param {number} limit Maximum number of operations log entries in the response
         * @param {string} acceptLanguage The language and region identifier of the requested language in IETF BCP 47 format. If none is present, the default language will be used.
         * @param {Array<string>} [tenant] IDs of the tenants (short name)
         * @param {number} [offset] The offset of the entries. The entries are sorted by log timestamp. E.g. an offset of 100 omits the first 100 most recent entries.
         * @param {string} [lastEntry] The id of the last entry that was already loaded by the client of this API. The entries \&#39;after\&#39; this entry will be returned. Hence, it can be used to load a page \&#39;after\&#39; an already loaded one.
         * @param {string} [firstEntry] The id of the first entry that was already loaded by the client of this API. The entries \&#39;before\&#39; this entry will be returned. Hence, it can be used to load a page \&#39;before\&#39; an already loaded one.
         * @param {string} [timeFrameStart] The beginning of the time frame to query operations logs from. The time frame condition is applied to the point in time an operations log entry was last modified at. If this parameter is not provided by the client it defaults to the start of the current day. Must be provided as ISO 8601-1 string.
         * @param {string} [timeFrameEnd] The end of the time frame to query operations logs from. The time frame condition is applied to the point in time an operations log entry was last modified at. If this parameter is not provided by the client it defaults the current time (now). Must be provided as ISO 8601-1 string.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveOperationsLogs(limit: number, acceptLanguage: string, tenant?: Array<string>, offset?: number, lastEntry?: string, firstEntry?: string, timeFrameStart?: string, timeFrameEnd?: string, options?: any): AxiosPromise<OperationsLogPage> {
            return localVarFp.retrieveOperationsLogs(limit, acceptLanguage, tenant, offset, lastEntry, firstEntry, timeFrameStart, timeFrameEnd, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OperationsLogsApi - object-oriented interface
 * @export
 * @class OperationsLogsApi
 * @extends {BaseAPI}
 */
export class OperationsLogsApi extends BaseAPI {
    /**
     * Creates a new operations log entry. The entry must at least contain a text, a tenant and the user. If the new entry shall be associated to a vehicle, then the property vehicle->uid shall be set. The text will not be internationalized. It will be presented to every user as it was specified independently of the user\'s language.
     * @param {OperationsLogEntry} [operationsLogEntry] All readonly properties will be ignored. Furthermore, all referenced objects except for the VehicleIdentification (so it can be used to provide the UID of a vehicle) will be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsLogsApi
     */
    public createOperationsLogEntry(operationsLogEntry?: OperationsLogEntry, options?: AxiosRequestConfig) {
        return OperationsLogsApiFp(this.configuration).createOperationsLogEntry(operationsLogEntry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all the currently available operations log entries sorted by logTimestamp in descending order.
     * @param {number} limit Maximum number of operations log entries in the response
     * @param {string} acceptLanguage The language and region identifier of the requested language in IETF BCP 47 format. If none is present, the default language will be used.
     * @param {Array<string>} [tenant] IDs of the tenants (short name)
     * @param {number} [offset] The offset of the entries. The entries are sorted by log timestamp. E.g. an offset of 100 omits the first 100 most recent entries.
     * @param {string} [lastEntry] The id of the last entry that was already loaded by the client of this API. The entries \&#39;after\&#39; this entry will be returned. Hence, it can be used to load a page \&#39;after\&#39; an already loaded one.
     * @param {string} [firstEntry] The id of the first entry that was already loaded by the client of this API. The entries \&#39;before\&#39; this entry will be returned. Hence, it can be used to load a page \&#39;before\&#39; an already loaded one.
     * @param {string} [timeFrameStart] The beginning of the time frame to query operations logs from. The time frame condition is applied to the point in time an operations log entry was last modified at. If this parameter is not provided by the client it defaults to the start of the current day. Must be provided as ISO 8601-1 string.
     * @param {string} [timeFrameEnd] The end of the time frame to query operations logs from. The time frame condition is applied to the point in time an operations log entry was last modified at. If this parameter is not provided by the client it defaults the current time (now). Must be provided as ISO 8601-1 string.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OperationsLogsApi
     */
    public retrieveOperationsLogs(limit: number, acceptLanguage: string, tenant?: Array<string>, offset?: number, lastEntry?: string, firstEntry?: string, timeFrameStart?: string, timeFrameEnd?: string, options?: AxiosRequestConfig) {
        return OperationsLogsApiFp(this.configuration).retrieveOperationsLogs(limit, acceptLanguage, tenant, offset, lastEntry, firstEntry, timeFrameStart, timeFrameEnd, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RadioMessagesApi - axios parameter creator
 * @export
 */
export const RadioMessagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Method to acknowledge i.e. delete radio messages.
         * @param {Array<string>} uid UIDs of the radio messages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acknowledgeRadioMessages: async (uid: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('acknowledgeRadioMessages', 'uid', uid)
            const localVarPath = `/gw/radioMessages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (uid) {
                localVarQueryParameter['uid'] = uid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Method to assign a radio message to a user or unassign to no one.
         * @param {Array<string>} uid UIDs of the radio messages
         * @param {RadioMessagesAssignmentBody} radioMessagesAssignmentBody Information about the user to be assigned to. If the user property is null, the user will be unassigned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignRadioMessage: async (uid: Array<string>, radioMessagesAssignmentBody: RadioMessagesAssignmentBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('assignRadioMessage', 'uid', uid)
            // verify required parameter 'radioMessagesAssignmentBody' is not null or undefined
            assertParamExists('assignRadioMessage', 'radioMessagesAssignmentBody', radioMessagesAssignmentBody)
            const localVarPath = `/gw/radioMessages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (uid) {
                localVarQueryParameter['uid'] = uid;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(radioMessagesAssignmentBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns all currently available radio messages.
         * @param {string} acceptLanguage The language and region identifier of the requested language in IETF BCP 47 format. If none is present, the default language will be used.
         * @param {Array<string>} [tenant] IDs of the tenants (short name)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRadioMessages: async (acceptLanguage: string, tenant?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'acceptLanguage' is not null or undefined
            assertParamExists('retrieveRadioMessages', 'acceptLanguage', acceptLanguage)
            const localVarPath = `/gw/radioMessages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tenant) {
                localVarQueryParameter['tenant'] = tenant.join(COLLECTION_FORMATS.csv);
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RadioMessagesApi - functional programming interface
 * @export
 */
export const RadioMessagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RadioMessagesApiAxiosParamCreator(configuration)
    return {
        /**
         * Method to acknowledge i.e. delete radio messages.
         * @param {Array<string>} uid UIDs of the radio messages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acknowledgeRadioMessages(uid: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModificationResultResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.acknowledgeRadioMessages(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Method to assign a radio message to a user or unassign to no one.
         * @param {Array<string>} uid UIDs of the radio messages
         * @param {RadioMessagesAssignmentBody} radioMessagesAssignmentBody Information about the user to be assigned to. If the user property is null, the user will be unassigned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignRadioMessage(uid: Array<string>, radioMessagesAssignmentBody: RadioMessagesAssignmentBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModificationResultResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignRadioMessage(uid, radioMessagesAssignmentBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns all currently available radio messages.
         * @param {string} acceptLanguage The language and region identifier of the requested language in IETF BCP 47 format. If none is present, the default language will be used.
         * @param {Array<string>} [tenant] IDs of the tenants (short name)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRadioMessages(acceptLanguage: string, tenant?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RadioMessagesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRadioMessages(acceptLanguage, tenant, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RadioMessagesApi - factory interface
 * @export
 */
export const RadioMessagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RadioMessagesApiFp(configuration)
    return {
        /**
         * Method to acknowledge i.e. delete radio messages.
         * @param {Array<string>} uid UIDs of the radio messages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acknowledgeRadioMessages(uid: Array<string>, options?: any): AxiosPromise<ModificationResultResponse> {
            return localVarFp.acknowledgeRadioMessages(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * Method to assign a radio message to a user or unassign to no one.
         * @param {Array<string>} uid UIDs of the radio messages
         * @param {RadioMessagesAssignmentBody} radioMessagesAssignmentBody Information about the user to be assigned to. If the user property is null, the user will be unassigned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignRadioMessage(uid: Array<string>, radioMessagesAssignmentBody: RadioMessagesAssignmentBody, options?: any): AxiosPromise<ModificationResultResponse> {
            return localVarFp.assignRadioMessage(uid, radioMessagesAssignmentBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns all currently available radio messages.
         * @param {string} acceptLanguage The language and region identifier of the requested language in IETF BCP 47 format. If none is present, the default language will be used.
         * @param {Array<string>} [tenant] IDs of the tenants (short name)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRadioMessages(acceptLanguage: string, tenant?: Array<string>, options?: any): AxiosPromise<RadioMessagesResponse> {
            return localVarFp.retrieveRadioMessages(acceptLanguage, tenant, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RadioMessagesApi - object-oriented interface
 * @export
 * @class RadioMessagesApi
 * @extends {BaseAPI}
 */
export class RadioMessagesApi extends BaseAPI {
    /**
     * Method to acknowledge i.e. delete radio messages.
     * @param {Array<string>} uid UIDs of the radio messages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadioMessagesApi
     */
    public acknowledgeRadioMessages(uid: Array<string>, options?: AxiosRequestConfig) {
        return RadioMessagesApiFp(this.configuration).acknowledgeRadioMessages(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Method to assign a radio message to a user or unassign to no one.
     * @param {Array<string>} uid UIDs of the radio messages
     * @param {RadioMessagesAssignmentBody} radioMessagesAssignmentBody Information about the user to be assigned to. If the user property is null, the user will be unassigned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadioMessagesApi
     */
    public assignRadioMessage(uid: Array<string>, radioMessagesAssignmentBody: RadioMessagesAssignmentBody, options?: AxiosRequestConfig) {
        return RadioMessagesApiFp(this.configuration).assignRadioMessage(uid, radioMessagesAssignmentBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns all currently available radio messages.
     * @param {string} acceptLanguage The language and region identifier of the requested language in IETF BCP 47 format. If none is present, the default language will be used.
     * @param {Array<string>} [tenant] IDs of the tenants (short name)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RadioMessagesApi
     */
    public retrieveRadioMessages(acceptLanguage: string, tenant?: Array<string>, options?: AxiosRequestConfig) {
        return RadioMessagesApiFp(this.configuration).retrieveRadioMessages(acceptLanguage, tenant, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TenantsApi - axios parameter creator
 * @export
 */
export const TenantsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a list of all tenants available in the system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveTenants: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/gw/tenants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TenantsApi - functional programming interface
 * @export
 */
export const TenantsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TenantsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves a list of all tenants available in the system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveTenants(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveTenants(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TenantsApi - factory interface
 * @export
 */
export const TenantsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TenantsApiFp(configuration)
    return {
        /**
         * Retrieves a list of all tenants available in the system.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveTenants(options?: any): AxiosPromise<TenantsResponse> {
            return localVarFp.retrieveTenants(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TenantsApi - object-oriented interface
 * @export
 * @class TenantsApi
 * @extends {BaseAPI}
 */
export class TenantsApi extends BaseAPI {
    /**
     * Retrieves a list of all tenants available in the system.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantsApi
     */
    public retrieveTenants(options?: AxiosRequestConfig) {
        return TenantsApiFp(this.configuration).retrieveTenants(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TripsApi - axios parameter creator
 * @export
 */
export const TripsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves data about the trip itineraries queried. At least one parameter has to be given. The parameters vehicleUid and tripUid can be combined, but when given a blockUid the other parameters are not permitted. Conversely, if tripUid, vehicleUid or both are present, a blockUid must not be present. Please also note that at most one blockUid can be provided.
         * @param {string} acceptLanguage The language and region identifier of the requested language in IETF BCP 47 format. If none is present, the default language will be used.
         * @param {Array<string>} [vehicleUid] The UIDs of the vehicles whose tripItineraries should be returned. If a vehicle has no associated trip it will not be represented in the result set. Only vehicles with registration state \&quot;OPERATIONAL\&quot; will have a trip itinerary.
         * @param {Array<string>} [tripUid] The UIDs of the trips whose tripItineraries should be returned.
         * @param {string} [blockUid] The UID of the block whose tripItineraries should be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveTripItineraries: async (acceptLanguage: string, vehicleUid?: Array<string>, tripUid?: Array<string>, blockUid?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'acceptLanguage' is not null or undefined
            assertParamExists('retrieveTripItineraries', 'acceptLanguage', acceptLanguage)
            const localVarPath = `/gw/tripItineraries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (vehicleUid) {
                localVarQueryParameter['vehicleUid'] = vehicleUid;
            }

            if (tripUid) {
                localVarQueryParameter['tripUid'] = tripUid;
            }

            if (blockUid !== undefined) {
                localVarQueryParameter['blockUid'] = blockUid;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TripsApi - functional programming interface
 * @export
 */
export const TripsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TripsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves data about the trip itineraries queried. At least one parameter has to be given. The parameters vehicleUid and tripUid can be combined, but when given a blockUid the other parameters are not permitted. Conversely, if tripUid, vehicleUid or both are present, a blockUid must not be present. Please also note that at most one blockUid can be provided.
         * @param {string} acceptLanguage The language and region identifier of the requested language in IETF BCP 47 format. If none is present, the default language will be used.
         * @param {Array<string>} [vehicleUid] The UIDs of the vehicles whose tripItineraries should be returned. If a vehicle has no associated trip it will not be represented in the result set. Only vehicles with registration state \&quot;OPERATIONAL\&quot; will have a trip itinerary.
         * @param {Array<string>} [tripUid] The UIDs of the trips whose tripItineraries should be returned.
         * @param {string} [blockUid] The UID of the block whose tripItineraries should be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveTripItineraries(acceptLanguage: string, vehicleUid?: Array<string>, tripUid?: Array<string>, blockUid?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TripItinerariesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveTripItineraries(acceptLanguage, vehicleUid, tripUid, blockUid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TripsApi - factory interface
 * @export
 */
export const TripsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TripsApiFp(configuration)
    return {
        /**
         * Retrieves data about the trip itineraries queried. At least one parameter has to be given. The parameters vehicleUid and tripUid can be combined, but when given a blockUid the other parameters are not permitted. Conversely, if tripUid, vehicleUid or both are present, a blockUid must not be present. Please also note that at most one blockUid can be provided.
         * @param {string} acceptLanguage The language and region identifier of the requested language in IETF BCP 47 format. If none is present, the default language will be used.
         * @param {Array<string>} [vehicleUid] The UIDs of the vehicles whose tripItineraries should be returned. If a vehicle has no associated trip it will not be represented in the result set. Only vehicles with registration state \&quot;OPERATIONAL\&quot; will have a trip itinerary.
         * @param {Array<string>} [tripUid] The UIDs of the trips whose tripItineraries should be returned.
         * @param {string} [blockUid] The UID of the block whose tripItineraries should be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveTripItineraries(acceptLanguage: string, vehicleUid?: Array<string>, tripUid?: Array<string>, blockUid?: string, options?: any): AxiosPromise<TripItinerariesResponse> {
            return localVarFp.retrieveTripItineraries(acceptLanguage, vehicleUid, tripUid, blockUid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TripsApi - object-oriented interface
 * @export
 * @class TripsApi
 * @extends {BaseAPI}
 */
export class TripsApi extends BaseAPI {
    /**
     * Retrieves data about the trip itineraries queried. At least one parameter has to be given. The parameters vehicleUid and tripUid can be combined, but when given a blockUid the other parameters are not permitted. Conversely, if tripUid, vehicleUid or both are present, a blockUid must not be present. Please also note that at most one blockUid can be provided.
     * @param {string} acceptLanguage The language and region identifier of the requested language in IETF BCP 47 format. If none is present, the default language will be used.
     * @param {Array<string>} [vehicleUid] The UIDs of the vehicles whose tripItineraries should be returned. If a vehicle has no associated trip it will not be represented in the result set. Only vehicles with registration state \&quot;OPERATIONAL\&quot; will have a trip itinerary.
     * @param {Array<string>} [tripUid] The UIDs of the trips whose tripItineraries should be returned.
     * @param {string} [blockUid] The UID of the block whose tripItineraries should be returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TripsApi
     */
    public retrieveTripItineraries(acceptLanguage: string, vehicleUid?: Array<string>, tripUid?: Array<string>, blockUid?: string, options?: AxiosRequestConfig) {
        return TripsApiFp(this.configuration).retrieveTripItineraries(acceptLanguage, vehicleUid, tripUid, blockUid, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UpdatesOnBlocksApi - axios parameter creator
 * @export
 */
export const UpdatesOnBlocksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Removes the subscription with the given subscription ID.
         * @param {string} subscriptionId ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deregisterForCondensedBlockUpdates: async (subscriptionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('deregisterForCondensedBlockUpdates', 'subscriptionId', subscriptionId)
            const localVarPath = `/blocks/condensed/updates/subscriptions/{subscriptionId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes an existing subscription to the parameters supplied with the request body. This method can be used while already retrieving the update stream of the subscription. The changes are applied immediately.
         * @param {string} subscriptionId ID of the subscription
         * @param {BlockSubscriptionRequestBody} blockSubscriptionRequestBody 
         * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifySubscriptionForCondensedBlocks: async (subscriptionId: string, blockSubscriptionRequestBody: BlockSubscriptionRequestBody, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('modifySubscriptionForCondensedBlocks', 'subscriptionId', subscriptionId)
            // verify required parameter 'blockSubscriptionRequestBody' is not null or undefined
            assertParamExists('modifySubscriptionForCondensedBlocks', 'blockSubscriptionRequestBody', blockSubscriptionRequestBody)
            const localVarPath = `/blocks/condensed/updates/subscriptions/{subscriptionId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(blockSubscriptionRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a subscription for updates. The response contains the ID to identify the subscription by.
         * @param {BlockSubscriptionRequestBody} blockSubscriptionRequestBody 
         * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerForCondensedBlockUpdates: async (blockSubscriptionRequestBody: BlockSubscriptionRequestBody, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'blockSubscriptionRequestBody' is not null or undefined
            assertParamExists('registerForCondensedBlockUpdates', 'blockSubscriptionRequestBody', blockSubscriptionRequestBody)
            const localVarPath = `/blocks/condensed/updates/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(blockSubscriptionRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the update stream for a previously registered subscription identified by its subscription ID.
         * @param {string} subscriptionId ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUpdatesForCondensedBlocks: async (subscriptionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('retrieveUpdatesForCondensedBlocks', 'subscriptionId', subscriptionId)
            const localVarPath = `/blocks/condensed/updates`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UpdatesOnBlocksApi - functional programming interface
 * @export
 */
export const UpdatesOnBlocksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UpdatesOnBlocksApiAxiosParamCreator(configuration)
    return {
        /**
         * Removes the subscription with the given subscription ID.
         * @param {string} subscriptionId ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deregisterForCondensedBlockUpdates(subscriptionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deregisterForCondensedBlockUpdates(subscriptionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Changes an existing subscription to the parameters supplied with the request body. This method can be used while already retrieving the update stream of the subscription. The changes are applied immediately.
         * @param {string} subscriptionId ID of the subscription
         * @param {BlockSubscriptionRequestBody} blockSubscriptionRequestBody 
         * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifySubscriptionForCondensedBlocks(subscriptionId: string, blockSubscriptionRequestBody: BlockSubscriptionRequestBody, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifySubscriptionForCondensedBlocks(subscriptionId, blockSubscriptionRequestBody, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a subscription for updates. The response contains the ID to identify the subscription by.
         * @param {BlockSubscriptionRequestBody} blockSubscriptionRequestBody 
         * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerForCondensedBlockUpdates(blockSubscriptionRequestBody: BlockSubscriptionRequestBody, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerForCondensedBlockUpdates(blockSubscriptionRequestBody, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the update stream for a previously registered subscription identified by its subscription ID.
         * @param {string} subscriptionId ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUpdatesForCondensedBlocks(subscriptionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CondensedBlockChange>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUpdatesForCondensedBlocks(subscriptionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UpdatesOnBlocksApi - factory interface
 * @export
 */
export const UpdatesOnBlocksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UpdatesOnBlocksApiFp(configuration)
    return {
        /**
         * Removes the subscription with the given subscription ID.
         * @param {string} subscriptionId ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deregisterForCondensedBlockUpdates(subscriptionId: string, options?: any): AxiosPromise<string> {
            return localVarFp.deregisterForCondensedBlockUpdates(subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes an existing subscription to the parameters supplied with the request body. This method can be used while already retrieving the update stream of the subscription. The changes are applied immediately.
         * @param {string} subscriptionId ID of the subscription
         * @param {BlockSubscriptionRequestBody} blockSubscriptionRequestBody 
         * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifySubscriptionForCondensedBlocks(subscriptionId: string, blockSubscriptionRequestBody: BlockSubscriptionRequestBody, acceptLanguage?: string, options?: any): AxiosPromise<string> {
            return localVarFp.modifySubscriptionForCondensedBlocks(subscriptionId, blockSubscriptionRequestBody, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a subscription for updates. The response contains the ID to identify the subscription by.
         * @param {BlockSubscriptionRequestBody} blockSubscriptionRequestBody 
         * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerForCondensedBlockUpdates(blockSubscriptionRequestBody: BlockSubscriptionRequestBody, acceptLanguage?: string, options?: any): AxiosPromise<SubscriptionResponse> {
            return localVarFp.registerForCondensedBlockUpdates(blockSubscriptionRequestBody, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the update stream for a previously registered subscription identified by its subscription ID.
         * @param {string} subscriptionId ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUpdatesForCondensedBlocks(subscriptionId: string, options?: any): AxiosPromise<Array<CondensedBlockChange>> {
            return localVarFp.retrieveUpdatesForCondensedBlocks(subscriptionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UpdatesOnBlocksApi - object-oriented interface
 * @export
 * @class UpdatesOnBlocksApi
 * @extends {BaseAPI}
 */
export class UpdatesOnBlocksApi extends BaseAPI {
    /**
     * Removes the subscription with the given subscription ID.
     * @param {string} subscriptionId ID of the subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdatesOnBlocksApi
     */
    public deregisterForCondensedBlockUpdates(subscriptionId: string, options?: AxiosRequestConfig) {
        return UpdatesOnBlocksApiFp(this.configuration).deregisterForCondensedBlockUpdates(subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Changes an existing subscription to the parameters supplied with the request body. This method can be used while already retrieving the update stream of the subscription. The changes are applied immediately.
     * @param {string} subscriptionId ID of the subscription
     * @param {BlockSubscriptionRequestBody} blockSubscriptionRequestBody 
     * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdatesOnBlocksApi
     */
    public modifySubscriptionForCondensedBlocks(subscriptionId: string, blockSubscriptionRequestBody: BlockSubscriptionRequestBody, acceptLanguage?: string, options?: AxiosRequestConfig) {
        return UpdatesOnBlocksApiFp(this.configuration).modifySubscriptionForCondensedBlocks(subscriptionId, blockSubscriptionRequestBody, acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a subscription for updates. The response contains the ID to identify the subscription by.
     * @param {BlockSubscriptionRequestBody} blockSubscriptionRequestBody 
     * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdatesOnBlocksApi
     */
    public registerForCondensedBlockUpdates(blockSubscriptionRequestBody: BlockSubscriptionRequestBody, acceptLanguage?: string, options?: AxiosRequestConfig) {
        return UpdatesOnBlocksApiFp(this.configuration).registerForCondensedBlockUpdates(blockSubscriptionRequestBody, acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the update stream for a previously registered subscription identified by its subscription ID.
     * @param {string} subscriptionId ID of the subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdatesOnBlocksApi
     */
    public retrieveUpdatesForCondensedBlocks(subscriptionId: string, options?: AxiosRequestConfig) {
        return UpdatesOnBlocksApiFp(this.configuration).retrieveUpdatesForCondensedBlocks(subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UpdatesOnDisruptionReportsApi - axios parameter creator
 * @export
 */
export const UpdatesOnDisruptionReportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Removes the subscription with the given subscription ID.
         * @param {string} subscriptionId ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deregisterForDisruptionReportUpdates: async (subscriptionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('deregisterForDisruptionReportUpdates', 'subscriptionId', subscriptionId)
            const localVarPath = `/disruptionReports/updates/subscriptions/{subscriptionId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes an existing subscription to the parameters supplied with the request body. This method can be used while already retrieving the update stream of the subscription. The changes are applied immediately.
         * @param {string} subscriptionId ID of the subscription
         * @param {DisruptionReportsSubscriptionRequestBody} disruptionReportsSubscriptionRequestBody 
         * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifySubscriptionForDisruptionReports: async (subscriptionId: string, disruptionReportsSubscriptionRequestBody: DisruptionReportsSubscriptionRequestBody, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('modifySubscriptionForDisruptionReports', 'subscriptionId', subscriptionId)
            // verify required parameter 'disruptionReportsSubscriptionRequestBody' is not null or undefined
            assertParamExists('modifySubscriptionForDisruptionReports', 'disruptionReportsSubscriptionRequestBody', disruptionReportsSubscriptionRequestBody)
            const localVarPath = `/disruptionReports/updates/subscriptions/{subscriptionId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(disruptionReportsSubscriptionRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a subscription for updates. The response contains the ID to identify the subscription by.
         * @param {DisruptionReportsSubscriptionRequestBody} disruptionReportsSubscriptionRequestBody 
         * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerForDisruptionReportUpdates: async (disruptionReportsSubscriptionRequestBody: DisruptionReportsSubscriptionRequestBody, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'disruptionReportsSubscriptionRequestBody' is not null or undefined
            assertParamExists('registerForDisruptionReportUpdates', 'disruptionReportsSubscriptionRequestBody', disruptionReportsSubscriptionRequestBody)
            const localVarPath = `/disruptionReports/updates/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(disruptionReportsSubscriptionRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the update stream for a previously registered subscription identified by its subscription ID.
         * @param {string} subscriptionId ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUpdatesForDisruptionReports: async (subscriptionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('retrieveUpdatesForDisruptionReports', 'subscriptionId', subscriptionId)
            const localVarPath = `/disruptionReports/updates`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UpdatesOnDisruptionReportsApi - functional programming interface
 * @export
 */
export const UpdatesOnDisruptionReportsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UpdatesOnDisruptionReportsApiAxiosParamCreator(configuration)
    return {
        /**
         * Removes the subscription with the given subscription ID.
         * @param {string} subscriptionId ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deregisterForDisruptionReportUpdates(subscriptionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deregisterForDisruptionReportUpdates(subscriptionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Changes an existing subscription to the parameters supplied with the request body. This method can be used while already retrieving the update stream of the subscription. The changes are applied immediately.
         * @param {string} subscriptionId ID of the subscription
         * @param {DisruptionReportsSubscriptionRequestBody} disruptionReportsSubscriptionRequestBody 
         * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifySubscriptionForDisruptionReports(subscriptionId: string, disruptionReportsSubscriptionRequestBody: DisruptionReportsSubscriptionRequestBody, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifySubscriptionForDisruptionReports(subscriptionId, disruptionReportsSubscriptionRequestBody, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a subscription for updates. The response contains the ID to identify the subscription by.
         * @param {DisruptionReportsSubscriptionRequestBody} disruptionReportsSubscriptionRequestBody 
         * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerForDisruptionReportUpdates(disruptionReportsSubscriptionRequestBody: DisruptionReportsSubscriptionRequestBody, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerForDisruptionReportUpdates(disruptionReportsSubscriptionRequestBody, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the update stream for a previously registered subscription identified by its subscription ID.
         * @param {string} subscriptionId ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUpdatesForDisruptionReports(subscriptionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DisruptionReportChange>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUpdatesForDisruptionReports(subscriptionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UpdatesOnDisruptionReportsApi - factory interface
 * @export
 */
export const UpdatesOnDisruptionReportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UpdatesOnDisruptionReportsApiFp(configuration)
    return {
        /**
         * Removes the subscription with the given subscription ID.
         * @param {string} subscriptionId ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deregisterForDisruptionReportUpdates(subscriptionId: string, options?: any): AxiosPromise<string> {
            return localVarFp.deregisterForDisruptionReportUpdates(subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes an existing subscription to the parameters supplied with the request body. This method can be used while already retrieving the update stream of the subscription. The changes are applied immediately.
         * @param {string} subscriptionId ID of the subscription
         * @param {DisruptionReportsSubscriptionRequestBody} disruptionReportsSubscriptionRequestBody 
         * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifySubscriptionForDisruptionReports(subscriptionId: string, disruptionReportsSubscriptionRequestBody: DisruptionReportsSubscriptionRequestBody, acceptLanguage?: string, options?: any): AxiosPromise<string> {
            return localVarFp.modifySubscriptionForDisruptionReports(subscriptionId, disruptionReportsSubscriptionRequestBody, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a subscription for updates. The response contains the ID to identify the subscription by.
         * @param {DisruptionReportsSubscriptionRequestBody} disruptionReportsSubscriptionRequestBody 
         * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerForDisruptionReportUpdates(disruptionReportsSubscriptionRequestBody: DisruptionReportsSubscriptionRequestBody, acceptLanguage?: string, options?: any): AxiosPromise<SubscriptionResponse> {
            return localVarFp.registerForDisruptionReportUpdates(disruptionReportsSubscriptionRequestBody, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the update stream for a previously registered subscription identified by its subscription ID.
         * @param {string} subscriptionId ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUpdatesForDisruptionReports(subscriptionId: string, options?: any): AxiosPromise<Array<DisruptionReportChange>> {
            return localVarFp.retrieveUpdatesForDisruptionReports(subscriptionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UpdatesOnDisruptionReportsApi - object-oriented interface
 * @export
 * @class UpdatesOnDisruptionReportsApi
 * @extends {BaseAPI}
 */
export class UpdatesOnDisruptionReportsApi extends BaseAPI {
    /**
     * Removes the subscription with the given subscription ID.
     * @param {string} subscriptionId ID of the subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdatesOnDisruptionReportsApi
     */
    public deregisterForDisruptionReportUpdates(subscriptionId: string, options?: AxiosRequestConfig) {
        return UpdatesOnDisruptionReportsApiFp(this.configuration).deregisterForDisruptionReportUpdates(subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Changes an existing subscription to the parameters supplied with the request body. This method can be used while already retrieving the update stream of the subscription. The changes are applied immediately.
     * @param {string} subscriptionId ID of the subscription
     * @param {DisruptionReportsSubscriptionRequestBody} disruptionReportsSubscriptionRequestBody 
     * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdatesOnDisruptionReportsApi
     */
    public modifySubscriptionForDisruptionReports(subscriptionId: string, disruptionReportsSubscriptionRequestBody: DisruptionReportsSubscriptionRequestBody, acceptLanguage?: string, options?: AxiosRequestConfig) {
        return UpdatesOnDisruptionReportsApiFp(this.configuration).modifySubscriptionForDisruptionReports(subscriptionId, disruptionReportsSubscriptionRequestBody, acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a subscription for updates. The response contains the ID to identify the subscription by.
     * @param {DisruptionReportsSubscriptionRequestBody} disruptionReportsSubscriptionRequestBody 
     * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdatesOnDisruptionReportsApi
     */
    public registerForDisruptionReportUpdates(disruptionReportsSubscriptionRequestBody: DisruptionReportsSubscriptionRequestBody, acceptLanguage?: string, options?: AxiosRequestConfig) {
        return UpdatesOnDisruptionReportsApiFp(this.configuration).registerForDisruptionReportUpdates(disruptionReportsSubscriptionRequestBody, acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the update stream for a previously registered subscription identified by its subscription ID.
     * @param {string} subscriptionId ID of the subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdatesOnDisruptionReportsApi
     */
    public retrieveUpdatesForDisruptionReports(subscriptionId: string, options?: AxiosRequestConfig) {
        return UpdatesOnDisruptionReportsApiFp(this.configuration).retrieveUpdatesForDisruptionReports(subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UpdatesOnEventsApi - axios parameter creator
 * @export
 */
export const UpdatesOnEventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Removes the subscription with the given subscription ID.
         * @param {string} subscriptionId ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deregisterForEventUpdates: async (subscriptionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('deregisterForEventUpdates', 'subscriptionId', subscriptionId)
            const localVarPath = `/events/updates/subscriptions/{subscriptionId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes an existing subscription to the parameters supplied with the request body. This method can be used while already retrieving the update stream of the subscription. The changes are applied immediately.
         * @param {string} subscriptionId ID of the subscription
         * @param {EventsSubscriptionRequestBody} eventsSubscriptionRequestBody 
         * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifySubscriptionForEvents: async (subscriptionId: string, eventsSubscriptionRequestBody: EventsSubscriptionRequestBody, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('modifySubscriptionForEvents', 'subscriptionId', subscriptionId)
            // verify required parameter 'eventsSubscriptionRequestBody' is not null or undefined
            assertParamExists('modifySubscriptionForEvents', 'eventsSubscriptionRequestBody', eventsSubscriptionRequestBody)
            const localVarPath = `/events/updates/subscriptions/{subscriptionId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventsSubscriptionRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a subscription for updates. The response contains the ID to identify the subscription by.
         * @param {EventsSubscriptionRequestBody} eventsSubscriptionRequestBody 
         * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerForEventUpdates: async (eventsSubscriptionRequestBody: EventsSubscriptionRequestBody, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventsSubscriptionRequestBody' is not null or undefined
            assertParamExists('registerForEventUpdates', 'eventsSubscriptionRequestBody', eventsSubscriptionRequestBody)
            const localVarPath = `/events/updates/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(eventsSubscriptionRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the update stream for a previously registered subscription identified by its subscription ID.
         * @param {string} subscriptionId ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUpdatesForEvents: async (subscriptionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('retrieveUpdatesForEvents', 'subscriptionId', subscriptionId)
            const localVarPath = `/events/updates`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UpdatesOnEventsApi - functional programming interface
 * @export
 */
export const UpdatesOnEventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UpdatesOnEventsApiAxiosParamCreator(configuration)
    return {
        /**
         * Removes the subscription with the given subscription ID.
         * @param {string} subscriptionId ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deregisterForEventUpdates(subscriptionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deregisterForEventUpdates(subscriptionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Changes an existing subscription to the parameters supplied with the request body. This method can be used while already retrieving the update stream of the subscription. The changes are applied immediately.
         * @param {string} subscriptionId ID of the subscription
         * @param {EventsSubscriptionRequestBody} eventsSubscriptionRequestBody 
         * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifySubscriptionForEvents(subscriptionId: string, eventsSubscriptionRequestBody: EventsSubscriptionRequestBody, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifySubscriptionForEvents(subscriptionId, eventsSubscriptionRequestBody, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a subscription for updates. The response contains the ID to identify the subscription by.
         * @param {EventsSubscriptionRequestBody} eventsSubscriptionRequestBody 
         * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerForEventUpdates(eventsSubscriptionRequestBody: EventsSubscriptionRequestBody, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerForEventUpdates(eventsSubscriptionRequestBody, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the update stream for a previously registered subscription identified by its subscription ID.
         * @param {string} subscriptionId ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUpdatesForEvents(subscriptionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EventChange>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUpdatesForEvents(subscriptionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UpdatesOnEventsApi - factory interface
 * @export
 */
export const UpdatesOnEventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UpdatesOnEventsApiFp(configuration)
    return {
        /**
         * Removes the subscription with the given subscription ID.
         * @param {string} subscriptionId ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deregisterForEventUpdates(subscriptionId: string, options?: any): AxiosPromise<string> {
            return localVarFp.deregisterForEventUpdates(subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes an existing subscription to the parameters supplied with the request body. This method can be used while already retrieving the update stream of the subscription. The changes are applied immediately.
         * @param {string} subscriptionId ID of the subscription
         * @param {EventsSubscriptionRequestBody} eventsSubscriptionRequestBody 
         * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifySubscriptionForEvents(subscriptionId: string, eventsSubscriptionRequestBody: EventsSubscriptionRequestBody, acceptLanguage?: string, options?: any): AxiosPromise<string> {
            return localVarFp.modifySubscriptionForEvents(subscriptionId, eventsSubscriptionRequestBody, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a subscription for updates. The response contains the ID to identify the subscription by.
         * @param {EventsSubscriptionRequestBody} eventsSubscriptionRequestBody 
         * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerForEventUpdates(eventsSubscriptionRequestBody: EventsSubscriptionRequestBody, acceptLanguage?: string, options?: any): AxiosPromise<SubscriptionResponse> {
            return localVarFp.registerForEventUpdates(eventsSubscriptionRequestBody, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the update stream for a previously registered subscription identified by its subscription ID.
         * @param {string} subscriptionId ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUpdatesForEvents(subscriptionId: string, options?: any): AxiosPromise<Array<EventChange>> {
            return localVarFp.retrieveUpdatesForEvents(subscriptionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UpdatesOnEventsApi - object-oriented interface
 * @export
 * @class UpdatesOnEventsApi
 * @extends {BaseAPI}
 */
export class UpdatesOnEventsApi extends BaseAPI {
    /**
     * Removes the subscription with the given subscription ID.
     * @param {string} subscriptionId ID of the subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdatesOnEventsApi
     */
    public deregisterForEventUpdates(subscriptionId: string, options?: AxiosRequestConfig) {
        return UpdatesOnEventsApiFp(this.configuration).deregisterForEventUpdates(subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Changes an existing subscription to the parameters supplied with the request body. This method can be used while already retrieving the update stream of the subscription. The changes are applied immediately.
     * @param {string} subscriptionId ID of the subscription
     * @param {EventsSubscriptionRequestBody} eventsSubscriptionRequestBody 
     * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdatesOnEventsApi
     */
    public modifySubscriptionForEvents(subscriptionId: string, eventsSubscriptionRequestBody: EventsSubscriptionRequestBody, acceptLanguage?: string, options?: AxiosRequestConfig) {
        return UpdatesOnEventsApiFp(this.configuration).modifySubscriptionForEvents(subscriptionId, eventsSubscriptionRequestBody, acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a subscription for updates. The response contains the ID to identify the subscription by.
     * @param {EventsSubscriptionRequestBody} eventsSubscriptionRequestBody 
     * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdatesOnEventsApi
     */
    public registerForEventUpdates(eventsSubscriptionRequestBody: EventsSubscriptionRequestBody, acceptLanguage?: string, options?: AxiosRequestConfig) {
        return UpdatesOnEventsApiFp(this.configuration).registerForEventUpdates(eventsSubscriptionRequestBody, acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the update stream for a previously registered subscription identified by its subscription ID.
     * @param {string} subscriptionId ID of the subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdatesOnEventsApi
     */
    public retrieveUpdatesForEvents(subscriptionId: string, options?: AxiosRequestConfig) {
        return UpdatesOnEventsApiFp(this.configuration).retrieveUpdatesForEvents(subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UpdatesOnRadioMessagesApi - axios parameter creator
 * @export
 */
export const UpdatesOnRadioMessagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Removes the subscription with the given subscription ID.
         * @param {string} subscriptionId ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deregisterForRadioMessageUpdates: async (subscriptionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('deregisterForRadioMessageUpdates', 'subscriptionId', subscriptionId)
            const localVarPath = `/radioMessages/updates/subscriptions/{subscriptionId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes an existing subscription to the parameters supplied with the request body. This method can be used while already retrieving the update stream of the subscription. The changes are applied immediately.
         * @param {string} subscriptionId ID of the subscription
         * @param {RadioMessagesSubscriptionRequestBody} radioMessagesSubscriptionRequestBody 
         * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifySubscriptionForRadioMessages: async (subscriptionId: string, radioMessagesSubscriptionRequestBody: RadioMessagesSubscriptionRequestBody, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('modifySubscriptionForRadioMessages', 'subscriptionId', subscriptionId)
            // verify required parameter 'radioMessagesSubscriptionRequestBody' is not null or undefined
            assertParamExists('modifySubscriptionForRadioMessages', 'radioMessagesSubscriptionRequestBody', radioMessagesSubscriptionRequestBody)
            const localVarPath = `/radioMessages/updates/subscriptions/{subscriptionId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(radioMessagesSubscriptionRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a subscription for updates. The response contains the ID to identify the subscription by.
         * @param {RadioMessagesSubscriptionRequestBody} radioMessagesSubscriptionRequestBody 
         * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerForRadioMessageUpdates: async (radioMessagesSubscriptionRequestBody: RadioMessagesSubscriptionRequestBody, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'radioMessagesSubscriptionRequestBody' is not null or undefined
            assertParamExists('registerForRadioMessageUpdates', 'radioMessagesSubscriptionRequestBody', radioMessagesSubscriptionRequestBody)
            const localVarPath = `/radioMessages/updates/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(radioMessagesSubscriptionRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the update stream for a previously registered subscription identified by its subscription ID.
         * @param {string} subscriptionId ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUpdatesForRadioMessages: async (subscriptionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('retrieveUpdatesForRadioMessages', 'subscriptionId', subscriptionId)
            const localVarPath = `/radioMessages/updates`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UpdatesOnRadioMessagesApi - functional programming interface
 * @export
 */
export const UpdatesOnRadioMessagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UpdatesOnRadioMessagesApiAxiosParamCreator(configuration)
    return {
        /**
         * Removes the subscription with the given subscription ID.
         * @param {string} subscriptionId ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deregisterForRadioMessageUpdates(subscriptionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deregisterForRadioMessageUpdates(subscriptionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Changes an existing subscription to the parameters supplied with the request body. This method can be used while already retrieving the update stream of the subscription. The changes are applied immediately.
         * @param {string} subscriptionId ID of the subscription
         * @param {RadioMessagesSubscriptionRequestBody} radioMessagesSubscriptionRequestBody 
         * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifySubscriptionForRadioMessages(subscriptionId: string, radioMessagesSubscriptionRequestBody: RadioMessagesSubscriptionRequestBody, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifySubscriptionForRadioMessages(subscriptionId, radioMessagesSubscriptionRequestBody, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a subscription for updates. The response contains the ID to identify the subscription by.
         * @param {RadioMessagesSubscriptionRequestBody} radioMessagesSubscriptionRequestBody 
         * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerForRadioMessageUpdates(radioMessagesSubscriptionRequestBody: RadioMessagesSubscriptionRequestBody, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerForRadioMessageUpdates(radioMessagesSubscriptionRequestBody, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the update stream for a previously registered subscription identified by its subscription ID.
         * @param {string} subscriptionId ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUpdatesForRadioMessages(subscriptionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RadioMessageChange>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUpdatesForRadioMessages(subscriptionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UpdatesOnRadioMessagesApi - factory interface
 * @export
 */
export const UpdatesOnRadioMessagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UpdatesOnRadioMessagesApiFp(configuration)
    return {
        /**
         * Removes the subscription with the given subscription ID.
         * @param {string} subscriptionId ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deregisterForRadioMessageUpdates(subscriptionId: string, options?: any): AxiosPromise<string> {
            return localVarFp.deregisterForRadioMessageUpdates(subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes an existing subscription to the parameters supplied with the request body. This method can be used while already retrieving the update stream of the subscription. The changes are applied immediately.
         * @param {string} subscriptionId ID of the subscription
         * @param {RadioMessagesSubscriptionRequestBody} radioMessagesSubscriptionRequestBody 
         * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifySubscriptionForRadioMessages(subscriptionId: string, radioMessagesSubscriptionRequestBody: RadioMessagesSubscriptionRequestBody, acceptLanguage?: string, options?: any): AxiosPromise<string> {
            return localVarFp.modifySubscriptionForRadioMessages(subscriptionId, radioMessagesSubscriptionRequestBody, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a subscription for updates. The response contains the ID to identify the subscription by.
         * @param {RadioMessagesSubscriptionRequestBody} radioMessagesSubscriptionRequestBody 
         * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerForRadioMessageUpdates(radioMessagesSubscriptionRequestBody: RadioMessagesSubscriptionRequestBody, acceptLanguage?: string, options?: any): AxiosPromise<SubscriptionResponse> {
            return localVarFp.registerForRadioMessageUpdates(radioMessagesSubscriptionRequestBody, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the update stream for a previously registered subscription identified by its subscription ID.
         * @param {string} subscriptionId ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUpdatesForRadioMessages(subscriptionId: string, options?: any): AxiosPromise<Array<RadioMessageChange>> {
            return localVarFp.retrieveUpdatesForRadioMessages(subscriptionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UpdatesOnRadioMessagesApi - object-oriented interface
 * @export
 * @class UpdatesOnRadioMessagesApi
 * @extends {BaseAPI}
 */
export class UpdatesOnRadioMessagesApi extends BaseAPI {
    /**
     * Removes the subscription with the given subscription ID.
     * @param {string} subscriptionId ID of the subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdatesOnRadioMessagesApi
     */
    public deregisterForRadioMessageUpdates(subscriptionId: string, options?: AxiosRequestConfig) {
        return UpdatesOnRadioMessagesApiFp(this.configuration).deregisterForRadioMessageUpdates(subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Changes an existing subscription to the parameters supplied with the request body. This method can be used while already retrieving the update stream of the subscription. The changes are applied immediately.
     * @param {string} subscriptionId ID of the subscription
     * @param {RadioMessagesSubscriptionRequestBody} radioMessagesSubscriptionRequestBody 
     * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdatesOnRadioMessagesApi
     */
    public modifySubscriptionForRadioMessages(subscriptionId: string, radioMessagesSubscriptionRequestBody: RadioMessagesSubscriptionRequestBody, acceptLanguage?: string, options?: AxiosRequestConfig) {
        return UpdatesOnRadioMessagesApiFp(this.configuration).modifySubscriptionForRadioMessages(subscriptionId, radioMessagesSubscriptionRequestBody, acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a subscription for updates. The response contains the ID to identify the subscription by.
     * @param {RadioMessagesSubscriptionRequestBody} radioMessagesSubscriptionRequestBody 
     * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdatesOnRadioMessagesApi
     */
    public registerForRadioMessageUpdates(radioMessagesSubscriptionRequestBody: RadioMessagesSubscriptionRequestBody, acceptLanguage?: string, options?: AxiosRequestConfig) {
        return UpdatesOnRadioMessagesApiFp(this.configuration).registerForRadioMessageUpdates(radioMessagesSubscriptionRequestBody, acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the update stream for a previously registered subscription identified by its subscription ID.
     * @param {string} subscriptionId ID of the subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdatesOnRadioMessagesApi
     */
    public retrieveUpdatesForRadioMessages(subscriptionId: string, options?: AxiosRequestConfig) {
        return UpdatesOnRadioMessagesApiFp(this.configuration).retrieveUpdatesForRadioMessages(subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UpdatesOnTripItinerariesApi - axios parameter creator
 * @export
 */
export const UpdatesOnTripItinerariesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Removes the subscription with the given subscription ID.
         * @param {string} subscriptionId ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deregisterForTripItinerariesUpdates: async (subscriptionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('deregisterForTripItinerariesUpdates', 'subscriptionId', subscriptionId)
            const localVarPath = `/tripItineraries/updates/subscriptions/{subscriptionId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes an existing subscription to the parameters supplied with the request body. This method can be used while already retrieving the update stream of the subscription. The changes are applied immediately.
         * @param {string} subscriptionId ID of the subscription
         * @param {TripItinerariesSubscriptionRequestBody} tripItinerariesSubscriptionRequestBody 
         * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifySubscriptionForTripItineraries: async (subscriptionId: string, tripItinerariesSubscriptionRequestBody: TripItinerariesSubscriptionRequestBody, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('modifySubscriptionForTripItineraries', 'subscriptionId', subscriptionId)
            // verify required parameter 'tripItinerariesSubscriptionRequestBody' is not null or undefined
            assertParamExists('modifySubscriptionForTripItineraries', 'tripItinerariesSubscriptionRequestBody', tripItinerariesSubscriptionRequestBody)
            const localVarPath = `/tripItineraries/updates/subscriptions/{subscriptionId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tripItinerariesSubscriptionRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a subscription for updates. The response contains the ID to identify the subscription by.
         * @param {TripItinerariesSubscriptionRequestBody} tripItinerariesSubscriptionRequestBody 
         * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerForTripItinerariesUpdates: async (tripItinerariesSubscriptionRequestBody: TripItinerariesSubscriptionRequestBody, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tripItinerariesSubscriptionRequestBody' is not null or undefined
            assertParamExists('registerForTripItinerariesUpdates', 'tripItinerariesSubscriptionRequestBody', tripItinerariesSubscriptionRequestBody)
            const localVarPath = `/tripItineraries/updates/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tripItinerariesSubscriptionRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the update stream for a previously registered subscription identified by its subscription ID.
         * @param {string} subscriptionId ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUpdatesForTripItineraries: async (subscriptionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('retrieveUpdatesForTripItineraries', 'subscriptionId', subscriptionId)
            const localVarPath = `/tripItineraries/updates`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UpdatesOnTripItinerariesApi - functional programming interface
 * @export
 */
export const UpdatesOnTripItinerariesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UpdatesOnTripItinerariesApiAxiosParamCreator(configuration)
    return {
        /**
         * Removes the subscription with the given subscription ID.
         * @param {string} subscriptionId ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deregisterForTripItinerariesUpdates(subscriptionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deregisterForTripItinerariesUpdates(subscriptionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Changes an existing subscription to the parameters supplied with the request body. This method can be used while already retrieving the update stream of the subscription. The changes are applied immediately.
         * @param {string} subscriptionId ID of the subscription
         * @param {TripItinerariesSubscriptionRequestBody} tripItinerariesSubscriptionRequestBody 
         * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifySubscriptionForTripItineraries(subscriptionId: string, tripItinerariesSubscriptionRequestBody: TripItinerariesSubscriptionRequestBody, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifySubscriptionForTripItineraries(subscriptionId, tripItinerariesSubscriptionRequestBody, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a subscription for updates. The response contains the ID to identify the subscription by.
         * @param {TripItinerariesSubscriptionRequestBody} tripItinerariesSubscriptionRequestBody 
         * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerForTripItinerariesUpdates(tripItinerariesSubscriptionRequestBody: TripItinerariesSubscriptionRequestBody, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerForTripItinerariesUpdates(tripItinerariesSubscriptionRequestBody, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the update stream for a previously registered subscription identified by its subscription ID.
         * @param {string} subscriptionId ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUpdatesForTripItineraries(subscriptionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TripItineraryChange>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUpdatesForTripItineraries(subscriptionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UpdatesOnTripItinerariesApi - factory interface
 * @export
 */
export const UpdatesOnTripItinerariesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UpdatesOnTripItinerariesApiFp(configuration)
    return {
        /**
         * Removes the subscription with the given subscription ID.
         * @param {string} subscriptionId ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deregisterForTripItinerariesUpdates(subscriptionId: string, options?: any): AxiosPromise<string> {
            return localVarFp.deregisterForTripItinerariesUpdates(subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes an existing subscription to the parameters supplied with the request body. This method can be used while already retrieving the update stream of the subscription. The changes are applied immediately.
         * @param {string} subscriptionId ID of the subscription
         * @param {TripItinerariesSubscriptionRequestBody} tripItinerariesSubscriptionRequestBody 
         * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifySubscriptionForTripItineraries(subscriptionId: string, tripItinerariesSubscriptionRequestBody: TripItinerariesSubscriptionRequestBody, acceptLanguage?: string, options?: any): AxiosPromise<string> {
            return localVarFp.modifySubscriptionForTripItineraries(subscriptionId, tripItinerariesSubscriptionRequestBody, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a subscription for updates. The response contains the ID to identify the subscription by.
         * @param {TripItinerariesSubscriptionRequestBody} tripItinerariesSubscriptionRequestBody 
         * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerForTripItinerariesUpdates(tripItinerariesSubscriptionRequestBody: TripItinerariesSubscriptionRequestBody, acceptLanguage?: string, options?: any): AxiosPromise<SubscriptionResponse> {
            return localVarFp.registerForTripItinerariesUpdates(tripItinerariesSubscriptionRequestBody, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the update stream for a previously registered subscription identified by its subscription ID.
         * @param {string} subscriptionId ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUpdatesForTripItineraries(subscriptionId: string, options?: any): AxiosPromise<Array<TripItineraryChange>> {
            return localVarFp.retrieveUpdatesForTripItineraries(subscriptionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UpdatesOnTripItinerariesApi - object-oriented interface
 * @export
 * @class UpdatesOnTripItinerariesApi
 * @extends {BaseAPI}
 */
export class UpdatesOnTripItinerariesApi extends BaseAPI {
    /**
     * Removes the subscription with the given subscription ID.
     * @param {string} subscriptionId ID of the subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdatesOnTripItinerariesApi
     */
    public deregisterForTripItinerariesUpdates(subscriptionId: string, options?: AxiosRequestConfig) {
        return UpdatesOnTripItinerariesApiFp(this.configuration).deregisterForTripItinerariesUpdates(subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Changes an existing subscription to the parameters supplied with the request body. This method can be used while already retrieving the update stream of the subscription. The changes are applied immediately.
     * @param {string} subscriptionId ID of the subscription
     * @param {TripItinerariesSubscriptionRequestBody} tripItinerariesSubscriptionRequestBody 
     * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdatesOnTripItinerariesApi
     */
    public modifySubscriptionForTripItineraries(subscriptionId: string, tripItinerariesSubscriptionRequestBody: TripItinerariesSubscriptionRequestBody, acceptLanguage?: string, options?: AxiosRequestConfig) {
        return UpdatesOnTripItinerariesApiFp(this.configuration).modifySubscriptionForTripItineraries(subscriptionId, tripItinerariesSubscriptionRequestBody, acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a subscription for updates. The response contains the ID to identify the subscription by.
     * @param {TripItinerariesSubscriptionRequestBody} tripItinerariesSubscriptionRequestBody 
     * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdatesOnTripItinerariesApi
     */
    public registerForTripItinerariesUpdates(tripItinerariesSubscriptionRequestBody: TripItinerariesSubscriptionRequestBody, acceptLanguage?: string, options?: AxiosRequestConfig) {
        return UpdatesOnTripItinerariesApiFp(this.configuration).registerForTripItinerariesUpdates(tripItinerariesSubscriptionRequestBody, acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the update stream for a previously registered subscription identified by its subscription ID.
     * @param {string} subscriptionId ID of the subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdatesOnTripItinerariesApi
     */
    public retrieveUpdatesForTripItineraries(subscriptionId: string, options?: AxiosRequestConfig) {
        return UpdatesOnTripItinerariesApiFp(this.configuration).retrieveUpdatesForTripItineraries(subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UpdatesOnVehicleStatesApi - axios parameter creator
 * @export
 */
export const UpdatesOnVehicleStatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Removes the subscription with the given subscription ID.
         * @param {string} subscriptionId ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deregisterForVehicleStateUpdates: async (subscriptionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('deregisterForVehicleStateUpdates', 'subscriptionId', subscriptionId)
            const localVarPath = `/vehicleStates/updates/subscriptions/{subscriptionId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes an existing subscription to the parameters supplied with the request body. This method can be used while already retrieving the update stream of the subscription. The changes are applied immediately.
         * @param {string} subscriptionId ID of the subscription
         * @param {VehicleStatesSubscriptionRequestBody} vehicleStatesSubscriptionRequestBody 
         * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifySubscriptionForVehicleStates: async (subscriptionId: string, vehicleStatesSubscriptionRequestBody: VehicleStatesSubscriptionRequestBody, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('modifySubscriptionForVehicleStates', 'subscriptionId', subscriptionId)
            // verify required parameter 'vehicleStatesSubscriptionRequestBody' is not null or undefined
            assertParamExists('modifySubscriptionForVehicleStates', 'vehicleStatesSubscriptionRequestBody', vehicleStatesSubscriptionRequestBody)
            const localVarPath = `/vehicleStates/updates/subscriptions/{subscriptionId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vehicleStatesSubscriptionRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a subscription for updates. The response contains the ID to identify the subscription by.
         * @param {VehicleStatesSubscriptionRequestBody} vehicleStatesSubscriptionRequestBody 
         * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerForVehicleStateUpdates: async (vehicleStatesSubscriptionRequestBody: VehicleStatesSubscriptionRequestBody, acceptLanguage?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vehicleStatesSubscriptionRequestBody' is not null or undefined
            assertParamExists('registerForVehicleStateUpdates', 'vehicleStatesSubscriptionRequestBody', vehicleStatesSubscriptionRequestBody)
            const localVarPath = `/vehicleStates/updates/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vehicleStatesSubscriptionRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the update stream for a previously registered subscription identified by its subscription ID.
         * @param {string} subscriptionId ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUpdatesForVehicleStates: async (subscriptionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('retrieveUpdatesForVehicleStates', 'subscriptionId', subscriptionId)
            const localVarPath = `/vehicleStates/updates`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UpdatesOnVehicleStatesApi - functional programming interface
 * @export
 */
export const UpdatesOnVehicleStatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UpdatesOnVehicleStatesApiAxiosParamCreator(configuration)
    return {
        /**
         * Removes the subscription with the given subscription ID.
         * @param {string} subscriptionId ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deregisterForVehicleStateUpdates(subscriptionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deregisterForVehicleStateUpdates(subscriptionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Changes an existing subscription to the parameters supplied with the request body. This method can be used while already retrieving the update stream of the subscription. The changes are applied immediately.
         * @param {string} subscriptionId ID of the subscription
         * @param {VehicleStatesSubscriptionRequestBody} vehicleStatesSubscriptionRequestBody 
         * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifySubscriptionForVehicleStates(subscriptionId: string, vehicleStatesSubscriptionRequestBody: VehicleStatesSubscriptionRequestBody, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifySubscriptionForVehicleStates(subscriptionId, vehicleStatesSubscriptionRequestBody, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Creates a subscription for updates. The response contains the ID to identify the subscription by.
         * @param {VehicleStatesSubscriptionRequestBody} vehicleStatesSubscriptionRequestBody 
         * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerForVehicleStateUpdates(vehicleStatesSubscriptionRequestBody: VehicleStatesSubscriptionRequestBody, acceptLanguage?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerForVehicleStateUpdates(vehicleStatesSubscriptionRequestBody, acceptLanguage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the update stream for a previously registered subscription identified by its subscription ID.
         * @param {string} subscriptionId ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUpdatesForVehicleStates(subscriptionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VehicleStateChange>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUpdatesForVehicleStates(subscriptionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UpdatesOnVehicleStatesApi - factory interface
 * @export
 */
export const UpdatesOnVehicleStatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UpdatesOnVehicleStatesApiFp(configuration)
    return {
        /**
         * Removes the subscription with the given subscription ID.
         * @param {string} subscriptionId ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deregisterForVehicleStateUpdates(subscriptionId: string, options?: any): AxiosPromise<string> {
            return localVarFp.deregisterForVehicleStateUpdates(subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Changes an existing subscription to the parameters supplied with the request body. This method can be used while already retrieving the update stream of the subscription. The changes are applied immediately.
         * @param {string} subscriptionId ID of the subscription
         * @param {VehicleStatesSubscriptionRequestBody} vehicleStatesSubscriptionRequestBody 
         * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifySubscriptionForVehicleStates(subscriptionId: string, vehicleStatesSubscriptionRequestBody: VehicleStatesSubscriptionRequestBody, acceptLanguage?: string, options?: any): AxiosPromise<string> {
            return localVarFp.modifySubscriptionForVehicleStates(subscriptionId, vehicleStatesSubscriptionRequestBody, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a subscription for updates. The response contains the ID to identify the subscription by.
         * @param {VehicleStatesSubscriptionRequestBody} vehicleStatesSubscriptionRequestBody 
         * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerForVehicleStateUpdates(vehicleStatesSubscriptionRequestBody: VehicleStatesSubscriptionRequestBody, acceptLanguage?: string, options?: any): AxiosPromise<SubscriptionResponse> {
            return localVarFp.registerForVehicleStateUpdates(vehicleStatesSubscriptionRequestBody, acceptLanguage, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the update stream for a previously registered subscription identified by its subscription ID.
         * @param {string} subscriptionId ID of the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUpdatesForVehicleStates(subscriptionId: string, options?: any): AxiosPromise<Array<VehicleStateChange>> {
            return localVarFp.retrieveUpdatesForVehicleStates(subscriptionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UpdatesOnVehicleStatesApi - object-oriented interface
 * @export
 * @class UpdatesOnVehicleStatesApi
 * @extends {BaseAPI}
 */
export class UpdatesOnVehicleStatesApi extends BaseAPI {
    /**
     * Removes the subscription with the given subscription ID.
     * @param {string} subscriptionId ID of the subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdatesOnVehicleStatesApi
     */
    public deregisterForVehicleStateUpdates(subscriptionId: string, options?: AxiosRequestConfig) {
        return UpdatesOnVehicleStatesApiFp(this.configuration).deregisterForVehicleStateUpdates(subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Changes an existing subscription to the parameters supplied with the request body. This method can be used while already retrieving the update stream of the subscription. The changes are applied immediately.
     * @param {string} subscriptionId ID of the subscription
     * @param {VehicleStatesSubscriptionRequestBody} vehicleStatesSubscriptionRequestBody 
     * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdatesOnVehicleStatesApi
     */
    public modifySubscriptionForVehicleStates(subscriptionId: string, vehicleStatesSubscriptionRequestBody: VehicleStatesSubscriptionRequestBody, acceptLanguage?: string, options?: AxiosRequestConfig) {
        return UpdatesOnVehicleStatesApiFp(this.configuration).modifySubscriptionForVehicleStates(subscriptionId, vehicleStatesSubscriptionRequestBody, acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Creates a subscription for updates. The response contains the ID to identify the subscription by.
     * @param {VehicleStatesSubscriptionRequestBody} vehicleStatesSubscriptionRequestBody 
     * @param {string} [acceptLanguage] The language and region identifier of the requested language in IETF BCP 47 format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdatesOnVehicleStatesApi
     */
    public registerForVehicleStateUpdates(vehicleStatesSubscriptionRequestBody: VehicleStatesSubscriptionRequestBody, acceptLanguage?: string, options?: AxiosRequestConfig) {
        return UpdatesOnVehicleStatesApiFp(this.configuration).registerForVehicleStateUpdates(vehicleStatesSubscriptionRequestBody, acceptLanguage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the update stream for a previously registered subscription identified by its subscription ID.
     * @param {string} subscriptionId ID of the subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UpdatesOnVehicleStatesApi
     */
    public retrieveUpdatesForVehicleStates(subscriptionId: string, options?: AxiosRequestConfig) {
        return UpdatesOnVehicleStatesApiFp(this.configuration).retrieveUpdatesForVehicleStates(subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VehiclesApi - axios parameter creator
 * @export
 */
export const VehiclesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves data about the vehicles queried.
         * @param {string} acceptLanguage The language and region identifier of the requested language in IETF BCP 47 format. If none is present, the default language will be used.
         * @param {Array<string>} [tenant] IDs of the tenants (short name)
         * @param {Array<VehicleRegistrationState>} [registrationState] Registration state of the vehicles. Only vehicles with the requested states will be returned in the result. If no registrationState is given, all vehicles will be returned independently of their registration state.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSelectableVehicles: async (acceptLanguage: string, tenant?: Array<string>, registrationState?: Array<VehicleRegistrationState>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'acceptLanguage' is not null or undefined
            assertParamExists('retrieveSelectableVehicles', 'acceptLanguage', acceptLanguage)
            const localVarPath = `/gw/selectableVehicles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tenant) {
                localVarQueryParameter['tenant'] = tenant.join(COLLECTION_FORMATS.csv);
            }

            if (registrationState) {
                localVarQueryParameter['registrationState'] = registrationState;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves data related to states of the vehicles queried. The method shall be used with at least one query parameter set (to a non-empty array).
         * @param {string} acceptLanguage The language and region identifier of the requested language in IETF BCP 47 format. If none is present, the default language will be used.
         * @param {Array<string>} [tenant] IDs of the tenants (short name)
         * @param {Array<string>} [vehicleUid] uid portion of VehicleIdentification. Only vehicle states matching will be returned in the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveVehicleStates: async (acceptLanguage: string, tenant?: Array<string>, vehicleUid?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'acceptLanguage' is not null or undefined
            assertParamExists('retrieveVehicleStates', 'acceptLanguage', acceptLanguage)
            const localVarPath = `/gw/vehicleStates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (tenant) {
                localVarQueryParameter['tenant'] = tenant.join(COLLECTION_FORMATS.csv);
            }

            if (vehicleUid) {
                localVarQueryParameter['vehicleUid'] = vehicleUid;
            }

            if (acceptLanguage != null) {
                localVarHeaderParameter['Accept-Language'] = String(acceptLanguage);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VehiclesApi - functional programming interface
 * @export
 */
export const VehiclesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VehiclesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves data about the vehicles queried.
         * @param {string} acceptLanguage The language and region identifier of the requested language in IETF BCP 47 format. If none is present, the default language will be used.
         * @param {Array<string>} [tenant] IDs of the tenants (short name)
         * @param {Array<VehicleRegistrationState>} [registrationState] Registration state of the vehicles. Only vehicles with the requested states will be returned in the result. If no registrationState is given, all vehicles will be returned independently of their registration state.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveSelectableVehicles(acceptLanguage: string, tenant?: Array<string>, registrationState?: Array<VehicleRegistrationState>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SelectableVehiclesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveSelectableVehicles(acceptLanguage, tenant, registrationState, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves data related to states of the vehicles queried. The method shall be used with at least one query parameter set (to a non-empty array).
         * @param {string} acceptLanguage The language and region identifier of the requested language in IETF BCP 47 format. If none is present, the default language will be used.
         * @param {Array<string>} [tenant] IDs of the tenants (short name)
         * @param {Array<string>} [vehicleUid] uid portion of VehicleIdentification. Only vehicle states matching will be returned in the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveVehicleStates(acceptLanguage: string, tenant?: Array<string>, vehicleUid?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VehicleStatesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveVehicleStates(acceptLanguage, tenant, vehicleUid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VehiclesApi - factory interface
 * @export
 */
export const VehiclesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VehiclesApiFp(configuration)
    return {
        /**
         * Retrieves data about the vehicles queried.
         * @param {string} acceptLanguage The language and region identifier of the requested language in IETF BCP 47 format. If none is present, the default language will be used.
         * @param {Array<string>} [tenant] IDs of the tenants (short name)
         * @param {Array<VehicleRegistrationState>} [registrationState] Registration state of the vehicles. Only vehicles with the requested states will be returned in the result. If no registrationState is given, all vehicles will be returned independently of their registration state.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSelectableVehicles(acceptLanguage: string, tenant?: Array<string>, registrationState?: Array<VehicleRegistrationState>, options?: any): AxiosPromise<SelectableVehiclesResponse> {
            return localVarFp.retrieveSelectableVehicles(acceptLanguage, tenant, registrationState, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves data related to states of the vehicles queried. The method shall be used with at least one query parameter set (to a non-empty array).
         * @param {string} acceptLanguage The language and region identifier of the requested language in IETF BCP 47 format. If none is present, the default language will be used.
         * @param {Array<string>} [tenant] IDs of the tenants (short name)
         * @param {Array<string>} [vehicleUid] uid portion of VehicleIdentification. Only vehicle states matching will be returned in the result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveVehicleStates(acceptLanguage: string, tenant?: Array<string>, vehicleUid?: Array<string>, options?: any): AxiosPromise<VehicleStatesResponse> {
            return localVarFp.retrieveVehicleStates(acceptLanguage, tenant, vehicleUid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VehiclesApi - object-oriented interface
 * @export
 * @class VehiclesApi
 * @extends {BaseAPI}
 */
export class VehiclesApi extends BaseAPI {
    /**
     * Retrieves data about the vehicles queried.
     * @param {string} acceptLanguage The language and region identifier of the requested language in IETF BCP 47 format. If none is present, the default language will be used.
     * @param {Array<string>} [tenant] IDs of the tenants (short name)
     * @param {Array<VehicleRegistrationState>} [registrationState] Registration state of the vehicles. Only vehicles with the requested states will be returned in the result. If no registrationState is given, all vehicles will be returned independently of their registration state.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehiclesApi
     */
    public retrieveSelectableVehicles(acceptLanguage: string, tenant?: Array<string>, registrationState?: Array<VehicleRegistrationState>, options?: AxiosRequestConfig) {
        return VehiclesApiFp(this.configuration).retrieveSelectableVehicles(acceptLanguage, tenant, registrationState, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves data related to states of the vehicles queried. The method shall be used with at least one query parameter set (to a non-empty array).
     * @param {string} acceptLanguage The language and region identifier of the requested language in IETF BCP 47 format. If none is present, the default language will be used.
     * @param {Array<string>} [tenant] IDs of the tenants (short name)
     * @param {Array<string>} [vehicleUid] uid portion of VehicleIdentification. Only vehicle states matching will be returned in the result.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VehiclesApi
     */
    public retrieveVehicleStates(acceptLanguage: string, tenant?: Array<string>, vehicleUid?: Array<string>, options?: AxiosRequestConfig) {
        return VehiclesApiFp(this.configuration).retrieveVehicleStates(acceptLanguage, tenant, vehicleUid, options).then((request) => request(this.axios, this.basePath));
    }
}


